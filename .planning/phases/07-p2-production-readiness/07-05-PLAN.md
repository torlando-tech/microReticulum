---
phase: 07-p2-production-readiness
plan: 05
type: execute
wave: 2
depends_on:
  - 07-01-PLAN.md
  - 07-02-PLAN.md
  - 07-03-PLAN.md
  - 07-04-PLAN.md
files_modified:
  - docs/CONCURRENCY.md
autonomous: true

must_haves:
  truths:
    - "Mutex ordering is documented with acquisition order to prevent deadlocks"
    - "All major mutexes are documented with purpose and typical holders"
    - "LVGL thread-safety rules are documented"
    - "Document lives in docs/CONCURRENCY.md"
  artifacts:
    - path: "docs/CONCURRENCY.md"
      provides: "Comprehensive concurrency documentation"
      contains: "Mutex Ordering"
  key_links:
    - from: "CONCURRENCY.md"
      to: "mutex list"
      via: "documentation"
      pattern: "## Mutexes"
---

<objective>
Create comprehensive concurrency documentation for mutex ordering and threading patterns.

Purpose: Document all concurrency patterns to prevent future deadlocks and race conditions (CONC-M9).
Output: docs/CONCURRENCY.md with mutex documentation, lock ordering, and threading rules.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-p2-production-readiness/07-CONTEXT.md
@.planning/phases/07-p2-production-readiness/07-RESEARCH.md

Reference for mutex patterns:
@src/UI/LVGL/LVGLLock.h
@src/BLE/platforms/NimBLEPlatform.h
@src/Transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive CONCURRENCY.md documentation</name>
  <files>docs/CONCURRENCY.md</files>
  <action>
Create docs/CONCURRENCY.md with the following structure:

```markdown
# Concurrency Guide

This document describes the threading model, mutex usage, and synchronization patterns in microReticulum.

## Threading Model

microReticulum runs on FreeRTOS with the following primary tasks:

| Task | Priority | Core | Purpose |
|------|----------|------|---------|
| LVGL UI Task | 5 | 1 | UI rendering and event handling |
| Transport Task | 4 | 0 | Packet processing and routing |
| WiFi Task | 3 | 0 | TCP interface management |
| BLE Task | 3 | 0 | BLE interface and scanning |

## Mutexes

### LVGL Mutex

- **Purpose**: Protects all LVGL widget operations
- **Header**: `src/UI/LVGL/LVGLLock.h`
- **Type**: Recursive mutex (allows nested locking from same task)
- **Timeout**: 5 seconds in debug builds (assert on timeout), portMAX_DELAY in release

**When to use**:
- Any code that calls lv_* functions outside the LVGL task
- Screen constructors and destructors
- Widget update methods (show, hide, refresh)

**Do NOT use**:
- Event callbacks (already run within LVGL task handler with mutex held)
- Code already running in LVGL task

**Usage pattern**:
```cpp
#include "UI/LVGL/LVGLLock.h"

void MyScreen::refresh() {
    LVGL_LOCK();  // RAII guard - unlocks on scope exit
    lv_label_set_text(label, "Updated");
}
```

### BLE Connection Mutex

- **Purpose**: Protects BLE connection map and discovered devices cache
- **Header**: `src/BLE/platforms/NimBLEPlatform.h`
- **Member**: `_conn_mutex`
- **Type**: Binary semaphore
- **Timeout**: 100ms for cache operations, varies for connection operations

**When to use**:
- Accessing `_connections` map
- Accessing `_discovered_devices` map
- During connect/disconnect operations

**Error handling**:
- Log warning on timeout (don't crash)
- Return gracefully without completing operation

### Transport Mutex

- **Purpose**: Protects packet queues and routing tables
- **Header**: `src/Transport.h`
- **Member**: Various internal mutexes
- **Type**: Binary semaphores

**When to use**:
- Adding/removing packets from queues
- Modifying destination table
- Path table operations

## Lock Ordering

To prevent deadlocks, acquire locks in this order:

```
1. Transport mutex (if needed)
2. BLE connection mutex (if needed)
3. LVGL mutex (if needed)
```

**Never** acquire:
- Transport mutex while holding LVGL mutex
- BLE mutex while holding LVGL mutex

This ordering ensures that:
- Lower-level (transport/BLE) operations complete before UI updates
- UI code can safely call transport/BLE APIs without deadlock

## LVGL Thread-Safety Rules

LVGL is single-threaded by design. All widget operations must be protected.

### Safe Patterns

1. **Constructor/Destructor**: Use LVGL_LOCK()
2. **Public methods called from other tasks**: Use LVGL_LOCK()
3. **Event callbacks**: Do NOT add lock (already protected)

### Unsafe Patterns

1. **Calling lv_* from ISR**: Never safe
2. **Nested LVGL_LOCK**: Safe (recursive mutex), but avoid if possible
3. **Long operations while holding lock**: Blocks UI rendering

### Screen Lifecycle

```cpp
MyScreen::MyScreen() {
    LVGL_LOCK();  // Required - constructor may run from any task
    _screen = lv_obj_create(lv_scr_act());
    // ... create widgets
}

MyScreen::~MyScreen() {
    LVGL_LOCK();  // Required - destructor may run from any task
    if (_screen) {
        lv_obj_del(_screen);
    }
}

void MyScreen::on_button_clicked(lv_event_t* event) {
    // No LVGL_LOCK needed - already in LVGL task context
    lv_label_set_text(label, "Clicked");
}
```

## Debug vs Release Behavior

| Component | Debug Build | Release Build |
|-----------|-------------|---------------|
| LVGL mutex | 5s timeout + assert | portMAX_DELAY |
| BLE cache mutex | 100ms timeout + log | 100ms timeout + log |
| I2S writes | 2s timeout + log | 2s timeout |

Debug builds crash-on-deadlock to surface issues during development.
Release builds continue operation, logging warnings for investigation.

## Common Pitfalls

### 1. Forgetting LVGL_LOCK in Destructor
**Problem**: Screen deleted while LVGL task is rendering
**Solution**: Always LVGL_LOCK in destructor before lv_obj_del

### 2. LVGL_LOCK in Event Callback
**Problem**: Potential double-acquire (even with recursive mutex, it's wasteful)
**Solution**: Event callbacks run within lv_task_handler - no lock needed

### 3. Long Operations While Holding Lock
**Problem**: UI becomes unresponsive
**Solution**: Copy data, release lock, process, reacquire for update

### 4. Accessing BLE Cache After Timeout
**Problem**: Stale data if mutex acquire failed
**Solution**: Check return value, handle timeout gracefully

## Task Priorities

Higher numbers = higher priority in FreeRTOS.

| Priority | Tasks | Rationale |
|----------|-------|-----------|
| 5 | LVGL | UI responsiveness |
| 4 | Transport | Packet processing |
| 3 | WiFi, BLE | Network I/O |
| 2 | Background | Non-critical processing |
| 1 | Idle | System idle task |

## Event Groups

Used for signaling between tasks without shared data.

| Group | Bits | Purpose |
|-------|------|---------|
| ble_event_group | BIT_SCAN_COMPLETE | Notify scan completion |
| transport_event_group | BIT_PACKET_READY | Notify packet available |

## References

- [FreeRTOS Mutex Documentation](https://www.freertos.org/Real-time-operating-system-tutorial.html)
- [LVGL Threading](https://docs.lvgl.io/master/porting/os.html)
- [ESP-IDF FreeRTOS](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos.html)
```
  </action>
  <verify>
- File exists at docs/CONCURRENCY.md
- Contains Mutex Ordering section
- Contains LVGL Thread-Safety Rules section
- Contains all major mutexes documented
  </verify>
  <done>docs/CONCURRENCY.md created with comprehensive concurrency documentation</done>
</task>

</tasks>

<verification>
1. docs/CONCURRENCY.md exists with complete content
2. Document includes: mutex list, lock ordering, LVGL rules, debug vs release behavior
3. All major mutexes are documented (LVGL, BLE, Transport)
4. Lock ordering is clear and prevents deadlocks
</verification>

<success_criteria>
- docs/CONCURRENCY.md exists and is comprehensive
- Lock ordering is documented
- All mutex usage patterns are explained
- Debug timeout behavior is documented
- Requirements satisfied: CONC-M9
</success_criteria>

<output>
After completion, create `.planning/phases/07-p2-production-readiness/07-05-SUMMARY.md`
</output>
