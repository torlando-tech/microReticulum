---
phase: 07-p2-production-readiness
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/BLE/platforms/NimBLEPlatform.h
  - src/BLE/platforms/NimBLEPlatform.cpp
autonomous: true

must_haves:
  truths:
    - "BLE discovered devices cache is bounded to 16 devices maximum"
    - "Connected devices are never evicted from cache"
    - "Cache eviction uses insertion-order (FIFO) for non-connected devices"
    - "Connection mutex timeout failures are logged"
  artifacts:
    - path: "src/BLE/platforms/NimBLEPlatform.h"
      provides: "Insertion order tracking vector"
      contains: "_discovered_order"
    - path: "src/BLE/platforms/NimBLEPlatform.cpp"
      provides: "Connected device protection during eviction"
      contains: "isDeviceConnected"
  key_links:
    - from: "onResult"
      to: "_discovered_order"
      via: "insertion tracking"
      pattern: "_discovered_order\\.push_back"
    - from: "eviction loop"
      to: "_connections"
      via: "connected device check"
      pattern: "isDeviceConnected"
---

<objective>
Implement bounded BLE discovered devices cache with connected device protection.

Purpose: Prevent unbounded memory growth in BLE scan results while ensuring connected devices are never evicted (CONC-M5, CONC-M6).
Output: Cache limited to 16 devices with insertion-order eviction and mutex timeout logging.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-p2-production-readiness/07-CONTEXT.md
@.planning/phases/07-p2-production-readiness/07-RESEARCH.md

Source files:
@src/BLE/platforms/NimBLEPlatform.h
@src/BLE/platforms/NimBLEPlatform.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add insertion-order tracking to NimBLEPlatform header</name>
  <files>src/BLE/platforms/NimBLEPlatform.h</files>
  <action>
Add a vector to track insertion order for FIFO eviction:

1. After line 276 (after `std::map<std::string, NimBLEAdvertisedDevice> _discovered_devices;`), add:
```cpp
    // Insertion-order tracking for FIFO eviction of discovered devices
    std::vector<std::string> _discovered_order;
```

2. Add a helper method declaration in the private section (around line 199, after `void updateConnectionMTU`):
```cpp
    // Check if a device address is currently connected
    bool isDeviceConnected(const std::string& addrKey) const;
```
  </action>
  <verify>
- Grep for `_discovered_order` in header
- Grep for `isDeviceConnected` declaration in header
- `pio run -e tdeck 2>&1 | grep -E "(error|warning)" | head -20` compiles without errors
  </verify>
  <done>NimBLEPlatform.h has insertion-order tracking vector and isDeviceConnected helper declaration</done>
</task>

<task type="auto">
  <name>Task 2: Implement connected device check and bounded cache eviction</name>
  <files>src/BLE/platforms/NimBLEPlatform.cpp</files>
  <action>
1. Add the isDeviceConnected helper implementation (after line 1504, near other connection helpers):
```cpp
bool NimBLEPlatform::isDeviceConnected(const std::string& addrKey) const {
    for (const auto& [handle, conn] : _connections) {
        if (conn.peer_address.toString() == addrKey) {
            return true;
        }
    }
    return false;
}
```

2. Replace the existing eviction code in onResult (lines 1752-1758) which currently does simple FIFO:
```cpp
        // Limit discovered device cache size to prevent memory growth
        // Remove oldest entry if at limit (simple FIFO approach)
        static constexpr size_t MAX_DISCOVERED_DEVICES = 16;
        while (_discovered_devices.size() >= MAX_DISCOVERED_DEVICES) {
            auto oldest = _discovered_devices.begin();
            _discovered_devices.erase(oldest);
        }
```

Replace with connected-device-aware eviction:
```cpp
        // Bounded cache with connected device protection (CONC-M6)
        static constexpr size_t MAX_DISCOVERED_DEVICES = 16;
        while (_discovered_devices.size() >= MAX_DISCOVERED_DEVICES) {
            bool evicted = false;
            // Find oldest non-connected device using insertion order
            for (auto it = _discovered_order.begin(); it != _discovered_order.end(); ++it) {
                if (!isDeviceConnected(*it)) {
                    _discovered_devices.erase(*it);
                    _discovered_order.erase(it);
                    evicted = true;
                    break;
                }
            }
            if (!evicted) {
                // All cached devices are connected - don't cache new one
                WARNING("NimBLEPlatform: Cannot cache device - all slots hold connected devices");
                return;
            }
        }
```

3. After the eviction loop, update the device insertion to track order (around line 1759):

BEFORE:
```cpp
        _discovered_devices[addrKey] = *advertisedDevice;
```

AFTER:
```cpp
        // Track insertion order for new devices
        auto existing = _discovered_devices.find(addrKey);
        if (existing == _discovered_devices.end()) {
            // New device - add to order tracking
            _discovered_order.push_back(addrKey);
        }
        _discovered_devices[addrKey] = *advertisedDevice;
```

4. Update the connect() method cache cleanup (around line 837-843) to also clean up order tracking:

BEFORE:
```cpp
    if (xSemaphoreTake(_conn_mutex, pdMS_TO_TICKS(100))) {
        auto cachedIt = _discovered_devices.find(addrKey);
        if (cachedIt != _discovered_devices.end()) {
            _discovered_devices.erase(cachedIt);
        }
        xSemaphoreGive(_conn_mutex);
    }
```

AFTER:
```cpp
    if (xSemaphoreTake(_conn_mutex, pdMS_TO_TICKS(100))) {
        auto cachedIt = _discovered_devices.find(addrKey);
        if (cachedIt != _discovered_devices.end()) {
            // Also remove from order tracking
            auto orderIt = std::find(_discovered_order.begin(),
                                      _discovered_order.end(), addrKey);
            if (orderIt != _discovered_order.end()) {
                _discovered_order.erase(orderIt);
            }
            _discovered_devices.erase(cachedIt);
        }
        xSemaphoreGive(_conn_mutex);
    } else {
        // CONC-M5: Log timeout failures
        WARNING("NimBLEPlatform: conn_mutex timeout (100ms) during cache update");
    }
```

5. Update recoverBLEStack (around line 264) to also clear order tracking:
Find `_discovered_devices.clear();` and add after it:
```cpp
    _discovered_order.clear();
```

6. Update shutdown (around line 217) to also clear order tracking:
Find `_discovered_devices.clear();` and add after it:
```cpp
    _discovered_order.clear();
```

7. Add `#include <algorithm>` if not already present (for std::find) - check near the top of the file.
  </action>
  <verify>
- Grep for `isDeviceConnected` implementation
- Grep for `_discovered_order` usage in onResult, connect, recoverBLEStack, shutdown
- Grep for "conn_mutex timeout" warning message
- `pio run -e tdeck 2>&1 | grep -E "(error|warning)" | head -20` compiles without errors
  </verify>
  <done>BLE cache bounded to 16 devices with connected device protection and mutex timeout logging</done>
</task>

</tasks>

<verification>
1. Full build compiles without errors: `pio run -e tdeck`
2. isDeviceConnected helper exists and checks _connections map
3. Eviction loop skips connected devices
4. Order tracking vector is maintained across insert/evict/clear operations
5. Mutex timeout failure is logged with WARNING
</verification>

<success_criteria>
- Build succeeds with 0 errors
- Cache is bounded to MAX_DISCOVERED_DEVICES (16)
- Connected devices are never evicted
- Order tracking is cleaned up in connect(), recoverBLEStack(), shutdown()
- Mutex timeout failures are logged (CONC-M5)
- Requirements satisfied: CONC-M5, CONC-M6
</success_criteria>

<output>
After completion, create `.planning/phases/07-p2-production-readiness/07-03-SUMMARY.md`
</output>
