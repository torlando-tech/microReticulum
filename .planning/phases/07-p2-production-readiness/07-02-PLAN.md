---
phase: 07-p2-production-readiness
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Bytes.cpp
  - src/Packet.h
autonomous: true

must_haves:
  truths:
    - "Bytes::newData uses std::make_shared for single-allocation pattern"
    - "PacketReceipt default constructor defers allocation until first use"
    - "Existing PacketReceipt usage continues to work (operator bool, accessors)"
  artifacts:
    - path: "src/Bytes.cpp"
      provides: "Single-allocation Bytes data"
      contains: "make_shared<Data>"
    - path: "src/Packet.h"
      provides: "Deferred PacketReceipt allocation"
      contains: "_object(nullptr)"
  key_links:
    - from: "Bytes::newData"
      to: "std::make_shared"
      via: "direct call"
      pattern: "make_shared<Data>"
    - from: "PacketReceipt accessors"
      to: "_object"
      via: "null check or assert"
      pattern: "assert\\(_object\\)"
---

<objective>
Optimize memory allocation patterns for Bytes and PacketReceipt classes.

Purpose: Reduce heap fragmentation by using make_shared (single allocation) and deferred allocation (MEM-M1, MEM-M2).
Output: More efficient memory usage for frequently-allocated objects.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-p2-production-readiness/07-CONTEXT.md
@.planning/phases/07-p2-production-readiness/07-RESEARCH.md

Source files:
@src/Bytes.cpp
@src/Bytes.h
@src/Packet.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert Bytes::newData to use make_shared</name>
  <files>src/Bytes.cpp</files>
  <action>
Modify the newData method (around lines 9-27) to use std::make_shared:

BEFORE (current implementation):
```cpp
void Bytes::newData(size_t capacity /*= 0*/) {
    Data* data = new Data();
    if (data == nullptr) {
        ERROR("Bytes failed to allocate empty data buffer");
        throw std::runtime_error("Failed to allocate empty data buffer");
    }
    if (capacity > 0) {
        data->reserve(capacity);
    }
    _data = SharedData(data);
    _exclusive = true;
}
```

AFTER (single allocation):
```cpp
void Bytes::newData(size_t capacity /*= 0*/) {
    // Single allocation via make_shared (combines control block + Data object)
    _data = std::make_shared<Data>();
    if (!_data) {
        ERROR("Bytes failed to allocate empty data buffer");
        throw std::runtime_error("Failed to allocate empty data buffer");
    }
    if (capacity > 0) {
        _data->reserve(capacity);
    }
    _exclusive = true;
}
```

Key changes:
1. Replace `Data* data = new Data();` + `_data = SharedData(data);` with `_data = std::make_shared<Data>();`
2. Update null check to use `if (!_data)` instead of `if (data == nullptr)`
3. Update reserve call to use `_data->reserve(capacity)` instead of `data->reserve()`
4. Remove the FIXME comment about make_shared since we're fixing it

Also apply the same pattern to exclusiveData (around lines 34-84) where it creates a new Data for COW copy:
- Lines 44-49: Replace `Data* data = new Data();` pattern with `auto new_data = std::make_shared<Data>();`
- Update subsequent references from `data->` to `new_data->`
- Update `_data = SharedData(data);` to `_data = new_data;`
  </action>
  <verify>
- Inspect Bytes.cpp to confirm make_shared usage in both newData and exclusiveData
- `pio run -e tdeck 2>&1 | grep -E "(error|warning)" | head -20` compiles without errors
  </verify>
  <done>Bytes uses make_shared for single-allocation pattern in newData and exclusiveData</done>
</task>

<task type="auto">
  <name>Task 2: Implement deferred allocation for PacketReceipt</name>
  <files>src/Packet.h</files>
  <action>
Modify PacketReceipt to defer Object allocation:

1. Change default constructor (line 52) from:
   `PacketReceipt() : _object(new Object()) {}`
   to:
   `PacketReceipt() : _object(nullptr) {}`

2. Add a private helper method after line 115 (before `private:` section):
```cpp
    // Ensure _object is allocated (lazy initialization)
    void ensure_object() {
        if (!_object) {
            _object = std::make_shared<Object>();
        }
    }
```

3. The existing `operator bool()` on line 61-63 already returns false for null _object:
   `return _object.get() != nullptr;`
   This means existing checks like `if (receipt)` continue to work correctly.

4. All accessor methods (lines 76-114) already have `assert(_object)` which will catch null dereference in debug builds. This is the correct behavior - callers should check `if (receipt)` before accessing.

NOTE: Do NOT modify the accessor methods to call ensure_object() automatically. The existing pattern of `assert(_object)` is correct because:
- Callers are expected to check `if (receipt)` before accessing members
- Forcing allocation on read would hide bugs
- The assert catches improper usage in debug builds
  </action>
  <verify>
- Inspect Packet.h to confirm:
  - Default constructor uses `_object(nullptr)`
  - ensure_object() helper exists
  - operator bool() still returns false for null _object
- `pio run -e tdeck 2>&1 | grep -E "(error|warning)" | head -20` compiles without errors
  </verify>
  <done>PacketReceipt defers allocation with default constructor using nullptr</done>
</task>

</tasks>

<verification>
1. Full build compiles without errors: `pio run -e tdeck`
2. Bytes.cpp uses make_shared in newData and exclusiveData
3. PacketReceipt default constructor initializes _object to nullptr
4. operator bool() correctly returns false for null _object
</verification>

<success_criteria>
- Build succeeds with 0 errors
- Bytes uses std::make_shared for single-allocation (removes FIXME comment)
- PacketReceipt default constructor defers allocation
- Requirements satisfied: MEM-M1, MEM-M2
</success_criteria>

<output>
After completion, create `.planning/phases/07-p2-production-readiness/07-02-SUMMARY.md`
</output>
