---
phase: 02-boot-profiling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Instrumentation/BootProfiler.h
  - src/Instrumentation/BootProfiler.cpp
autonomous: true

must_haves:
  truths:
    - "Boot phases are timed with millisecond precision"
    - "BootProfiler compiles to no-ops when disabled"
    - "Per-phase timings distinguish init time from wait time"
  artifacts:
    - path: "src/Instrumentation/BootProfiler.h"
      provides: "Public timing API with build flag guards"
      contains: "BOOT_PROFILING_ENABLED"
    - path: "src/Instrumentation/BootProfiler.cpp"
      provides: "Implementation using esp_timer_get_time or millis()"
      contains: "markStart"
  key_links:
    - from: "src/Instrumentation/BootProfiler.h"
      to: "BOOT_PROFILING_ENABLED build flag"
      via: "#ifdef guard and stub macros"
      pattern: "#ifdef BOOT_PROFILING_ENABLED"
---

<objective>
Create core BootProfiler module for timing boot sequence phases with millisecond precision.

Purpose: Establish instrumentation infrastructure that follows the same patterns as MemoryMonitor from Phase 1 (build flag isolation, static allocation, no-op when disabled).

Output: BootProfiler.h and BootProfiler.cpp in src/Instrumentation/ with API for marking phase starts/ends and distinguishing init time from blocking wait time.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-boot-profiling/02-RESEARCH.md
@.planning/phases/02-boot-profiling/02-CONTEXT.md
@src/Instrumentation/MemoryMonitor.h (reference pattern)
@src/Instrumentation/MemoryMonitor.cpp (reference implementation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BootProfiler header with API</name>
  <files>src/Instrumentation/BootProfiler.h</files>
  <action>
Create BootProfiler.h following MemoryMonitor.h pattern:

1. Build flag guard: `#ifdef BOOT_PROFILING_ENABLED`
2. Namespace: `RNS::Instrumentation`
3. Static class with these methods:
   - `static void markStart(const char* phase)` - Start timing a phase
   - `static void markEnd(const char* phase)` - End timing, log duration + cumulative
   - `static void markWaitStart(const char* phase)` - Start timing a blocking wait
   - `static void markWaitEnd(const char* phase)` - End wait timing (tracked separately)
   - `static void bootComplete()` - Log total boot time and summary
   - `static uint32_t getTotalMs()` - Get total boot duration so far
4. Private members:
   - Static buffer for log formatting (256 bytes, like MemoryMonitor)
   - Boot start timestamp
   - Current cumulative time
   - Phase tracking (name, start time)
   - Wait tracking separate from init tracking
5. Convenience macros when enabled:
   - `BOOT_PROFILE_START(phase)`
   - `BOOT_PROFILE_END(phase)`
   - `BOOT_PROFILE_WAIT_START(phase)`
   - `BOOT_PROFILE_WAIT_END(phase)`
   - `BOOT_PROFILE_COMPLETE()`
6. Stub macros when disabled (compile to `((void)0)`)

Include header comment explaining usage and purpose (matching MemoryMonitor style).
  </action>
  <verify>File exists at src/Instrumentation/BootProfiler.h with #ifdef guards and all declared methods</verify>
  <done>BootProfiler.h provides complete public API with build flag isolation</done>
</task>

<task type="auto">
  <name>Task 2: Implement BootProfiler timing logic</name>
  <files>src/Instrumentation/BootProfiler.cpp</files>
  <action>
Create BootProfiler.cpp implementing all header methods:

1. Build flag guard: `#ifdef BOOT_PROFILING_ENABLED`
2. Use `millis()` for timing (millisecond precision, already used in codebase, sufficient for boot profiling)
3. Static member initialization:
   - `_boot_start_ms = 0` (set on first markStart call)
   - `_cumulative_ms = 0`
   - `_current_phase[32]` - name of current phase
   - `_phase_start_ms = 0`
   - `_wait_start_ms = 0`
   - `_total_wait_ms = 0` - accumulated blocking wait time
   - `_log_buffer[256]` - static buffer for formatting
4. markStart implementation:
   - If first call, record _boot_start_ms
   - Store phase name and start time
   - Log: `[BOOT] START: {phase}`
5. markEnd implementation:
   - Calculate duration = now - _phase_start_ms
   - Update _cumulative_ms
   - Log: `[BOOT] END: {phase} ({duration}ms, cumulative: {cumulative}ms)`
6. markWaitStart/markWaitEnd:
   - Track wait time separately
   - Log: `[BOOT] WAIT: {phase} ({duration}ms)`
   - Add to _total_wait_ms
7. bootComplete:
   - Calculate total = now - _boot_start_ms
   - Calculate init_time = total - _total_wait_ms
   - Log summary: `[BOOT] COMPLETE: total={total}ms, init={init}ms, wait={wait}ms`
8. getTotalMs returns current cumulative time

Log format: Use snprintf into static buffer, then Serial.println().
  </action>
  <verify>File exists at src/Instrumentation/BootProfiler.cpp with all methods implemented</verify>
  <done>BootProfiler.cpp provides working timing implementation with serial output</done>
</task>

</tasks>

<verification>
- Both files exist in src/Instrumentation/
- Header has #ifdef BOOT_PROFILING_ENABLED guard
- Header has stub macros for when disabled
- Implementation uses static allocation only
- Log format shows phase name, duration, and cumulative time
</verification>

<success_criteria>
- BootProfiler module created with same quality as MemoryMonitor
- Build flag isolation ensures zero overhead when disabled
- API distinguishes init time from blocking wait time
- Ready for integration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/02-boot-profiling/02-01-SUMMARY.md`
</output>
