---
phase: 08-p3-optimization-hardening
plan: 07
type: execute
wave: 4
depends_on: ["08-04", "08-06"]
files_modified:
  - src/Packet.h
  - src/Packet.cpp
  - src/ObjectPool.h
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Packet::Object allocation uses pool instead of raw new"
    - "PacketReceipt::Object allocation uses pool instead of make_shared"
    - "Pool exhaustion falls back to heap allocation gracefully"
    - "Objects return to pool when Packet/PacketReceipt destroyed"
  artifacts:
    - path: "src/Packet.cpp"
      provides: "Pooled Object allocation"
      contains: "PacketObjectPool"
    - path: "src/Packet.h"
      provides: "Pool infrastructure and custom deleter"
      contains: "PacketObjectDeleter"
    - path: "src/ObjectPool.h"
      provides: "Extended template with constructor args support"
      exports: ["ObjectPool", "allocate"]
  key_links:
    - from: "src/Packet.cpp"
      to: "PacketObjectPool::allocate"
      via: "Packet constructor line 24"
      pattern: "PacketObjectPool.*allocate"
    - from: "PacketObjectDeleter"
      to: "PacketObjectPool::deallocate"
      via: "shared_ptr custom deleter"
      pattern: "deallocate"
---

<objective>
Integrate ObjectPool into Packet::Object allocation to eliminate per-packet heap fragmentation.

Purpose: Complete MEM-H2 requirement. Currently every Packet creates Object + shared_ptr control block on heap. For long-running firmware (months/years), this causes heap fragmentation. Pooling Object instances means the same ~24 slots are recycled forever.

Output: Packet and PacketReceipt use pool-backed Object allocation with custom deleters that return objects to pool.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-p3-optimization-hardening/08-06-SUMMARY.md

# Source files
@src/ObjectPool.h
@src/BytesPool.h
@src/Packet.h
@src/Packet.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ObjectPool to support constructor arguments</name>
  <files>src/ObjectPool.h</files>
  <action>
Modify ObjectPool::allocate() to accept variadic constructor arguments using perfect forwarding.

Current signature:
```cpp
T* allocate()
```

New signature:
```cpp
template<typename... Args>
T* allocate(Args&&... args)
```

Implementation:
1. Change placement new from `new (&_slots[slot].storage) T()` to `new (&_slots[slot].storage) T(std::forward<Args>(args)...)`
2. Add `#include <utility>` for std::forward
3. Keep the existing thread-safety (spinlock/mutex)
4. Keep fallback behavior (return nullptr on exhaustion)

This allows ObjectPool to construct objects with any constructor signature, which Packet::Object requires (takes Destination and Interface args).

Test mentally: `pool.allocate(destination, interface)` should work.
  </action>
  <verify>
Grep for "std::forward" in ObjectPool.h confirms variadic template.
Grep for "Args&&" confirms perfect forwarding syntax.
  </verify>
  <done>
ObjectPool::allocate() accepts constructor arguments via perfect forwarding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PacketObjectPool and integrate into Packet allocation</name>
  <files>src/Packet.h, src/Packet.cpp</files>
  <action>
Create pool infrastructure and integrate into Packet::Object allocation.

**In Packet.h (after Object class definition, before private _object member):**

1. Add PacketObjectPool type alias and accessor:
```cpp
// Pool for Packet::Object instances (MEM-H2)
// 24 slots covers typical concurrent packet count during high-throughput
// (receives + sends + retransmit queue)
static constexpr size_t PACKET_OBJECT_POOL_SIZE = 24;
using PacketObjectPool = ObjectPool<Object, PACKET_OBJECT_POOL_SIZE>;
static PacketObjectPool& objectPool();
```

2. Add custom deleter struct (similar to BytesPoolDeleter pattern):
```cpp
// Custom deleter returns Object to pool instead of destroying
struct PacketObjectDeleter {
    bool from_pool;

    explicit PacketObjectDeleter(bool pooled = false) : from_pool(pooled) {}

    void operator()(Object* obj) const {
        if (obj) {
            if (from_pool) {
                // Return to pool (destructor called by deallocate)
                objectPool().deallocate(obj);
            } else {
                // Heap fallback - normal delete
                delete obj;
            }
        }
    }
};
```

3. Change _object type from `std::shared_ptr<Object>` to use the deleter:
```cpp
// Note: shared_ptr with custom deleter has same size as regular shared_ptr
std::shared_ptr<Object> _object;  // unchanged type, but constructed differently
```

**In Packet.cpp:**

4. Add include at top:
```cpp
#include "ObjectPool.h"
```

5. Add pool singleton accessor (after namespace declaration):
```cpp
Packet::PacketObjectPool& Packet::objectPool() {
    static PacketObjectPool pool;
    return pool;
}
```

6. Modify Packet constructor (line 24, currently `_object(new Object(destination, attached_interface))`):
```cpp
// Try pool first, fall back to heap on exhaustion
Object* obj = objectPool().allocate(destination, attached_interface);
if (obj) {
    _object = std::shared_ptr<Object>(obj, PacketObjectDeleter{true});
} else {
    // Pool exhausted - fall back to heap (will happen during burst traffic)
    _object = std::shared_ptr<Object>(new Object(destination, attached_interface), PacketObjectDeleter{false});
}
```

Note: The constructor initialization list syntax won't work for this logic, so move _object initialization into the constructor body. Keep the delegation pattern for the Link constructor.

7. Update the Link constructor (line 68-84) similarly - it delegates to the main constructor, so no change needed there.

**Why 24 slots:**
- Typical concurrent packets: ~8-12 (receive buffer + send queue + retransmit)
- Burst allowance: 2x typical = 24
- Memory: 24 * ~600 bytes (Object size) = ~15KB pool
- Fallback to heap handles overflow gracefully
  </action>
  <verify>
```bash
grep -n "PacketObjectPool" src/Packet.h src/Packet.cpp
grep -n "PacketObjectDeleter" src/Packet.h src/Packet.cpp
grep -n "objectPool().allocate" src/Packet.cpp
```
All three should show matches.
  </verify>
  <done>
Packet::Object allocation uses pool with custom deleter, falls back to heap on exhaustion.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate pool into PacketReceipt::Object allocation</name>
  <files>src/Packet.h, src/Packet.cpp</files>
  <action>
Apply same pattern to PacketReceipt::Object (currently uses make_shared at line 119 and line 813).

**In Packet.h (inside PacketReceipt class, after Object class definition):**

1. Add pool type alias and accessor:
```cpp
// Pool for PacketReceipt::Object instances
static constexpr size_t RECEIPT_OBJECT_POOL_SIZE = 24;
using ReceiptObjectPool = ObjectPool<Object, RECEIPT_OBJECT_POOL_SIZE>;
static ReceiptObjectPool& objectPool();
```

2. Add custom deleter:
```cpp
struct ReceiptObjectDeleter {
    bool from_pool;

    explicit ReceiptObjectDeleter(bool pooled = false) : from_pool(pooled) {}

    void operator()(Object* obj) const {
        if (obj) {
            if (from_pool) {
                objectPool().deallocate(obj);
            } else {
                delete obj;
            }
        }
    }
};
```

**In Packet.cpp:**

3. Add pool singleton accessor:
```cpp
PacketReceipt::ReceiptObjectPool& PacketReceipt::objectPool() {
    static ReceiptObjectPool pool;
    return pool;
}
```

4. Modify ensure_object() method (line 117-121 in Packet.h):
Change from:
```cpp
void ensure_object() {
    if (!_object) {
        _object = std::make_shared<Object>();
    }
}
```
To:
```cpp
void ensure_object() {
    if (!_object) {
        Object* obj = objectPool().allocate();
        if (obj) {
            _object = std::shared_ptr<Object>(obj, ReceiptObjectDeleter{true});
        } else {
            _object = std::shared_ptr<Object>(new Object(), ReceiptObjectDeleter{false});
        }
    }
}
```

5. Modify PacketReceipt constructor in Packet.cpp (line 813, currently `_object(new Object())`):
```cpp
// Try pool first
Object* obj = objectPool().allocate();
if (obj) {
    _object = std::shared_ptr<Object>(obj, ReceiptObjectDeleter{true});
} else {
    _object = std::shared_ptr<Object>(new Object(), ReceiptObjectDeleter{false});
}
```

Move initialization from member initializer list to constructor body (similar to Packet).
  </action>
  <verify>
```bash
grep -n "ReceiptObjectPool" src/Packet.h src/Packet.cpp
grep -n "ReceiptObjectDeleter" src/Packet.h src/Packet.cpp
```
Both should show matches.
  </verify>
  <done>
PacketReceipt::Object allocation uses pool with custom deleter, falls back to heap on exhaustion.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Code structure verification:
```bash
# ObjectPool supports constructor args
grep -c "Args&&" src/ObjectPool.h  # Should be >= 1

# Packet uses pool
grep -c "PacketObjectPool" src/Packet.h  # Should be >= 2
grep -c "objectPool().allocate" src/Packet.cpp  # Should be >= 2

# PacketReceipt uses pool
grep -c "ReceiptObjectPool" src/Packet.h  # Should be >= 2
```

2. No raw `new Object()` remains in Packet.cpp for Packet or PacketReceipt allocation:
```bash
# This should NOT match line 24 or 813 anymore
grep -n "new Object(" src/Packet.cpp  # Only in fallback paths
```

3. Custom deleters defined:
```bash
grep -c "ObjectDeleter" src/Packet.h  # Should be >= 2 (Packet + Receipt)
```
</verification>

<success_criteria>
1. ObjectPool::allocate() accepts constructor arguments via perfect forwarding
2. Packet::Object allocation uses PacketObjectPool with 24 slots
3. PacketReceipt::Object allocation uses ReceiptObjectPool with 24 slots
4. Both have custom deleters that return objects to pool
5. Pool exhaustion gracefully falls back to heap allocation
6. MEM-H2 requirement satisfied - Packet Object uses pool allocator
</success_criteria>

<output>
After completion, create `.planning/phases/08-p3-optimization-hardening/08-07-SUMMARY.md`
</output>
