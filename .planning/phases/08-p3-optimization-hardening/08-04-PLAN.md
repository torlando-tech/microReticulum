---
phase: 08-p3-optimization-hardening
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src/Bytes.h
  - src/Packet.h
  - src/ObjectPool.h
autonomous: true

must_haves:
  truths:
    - "ObjectPool template provides thread-safe fixed-size pool infrastructure"
    - "Packet::Object fixed-size fields use inline buffers"
    - "Pool exhaustion falls back to nullptr (caller responsibility)"
    - "Bytes pool integration documented as future optimization"
  artifacts:
    - path: "src/ObjectPool.h"
      provides: "Generic fixed-size object pool with freelist"
      contains: "template.*ObjectPool"
    - path: "src/Bytes.h"
      provides: "Future optimization documentation"
      pattern: "FUTURE OPTIMIZATION.*Pool"
    - path: "src/Packet.h"
      provides: "Inline buffers for fixed-size fields"
      pattern: "uint8_t _packet_hash\\[|inline.*buffer"
  key_links: []
  # Note: Bytesâ†’ObjectPool integration deferred - inline buffers (Task 2) provide majority of savings
---

<objective>
Create ObjectPool infrastructure and add inline buffers for Packet fixed-size fields. Document Bytes pool integration as future work.

Purpose: Complete MEM-H3 (Packet inline buffers), deliver MEM-H2 infrastructure (ObjectPool template), defer MEM-H1 integration (Bytes pool - inline buffers provide majority of savings).

Output: Packet fixed-size fields save ~96 bytes per packet. ObjectPool template ready for future pooling needs.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-p3-optimization-hardening/08-RESEARCH.md

# Source files to modify
@src/Bytes.h
@src/Bytes.cpp
@src/Packet.h
@src/Type.h (for buffer size constants)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ObjectPool template class</name>
  <files>src/ObjectPool.h</files>
  <action>
    Create a new header file `src/ObjectPool.h` with a thread-safe fixed-size object pool:

    ```cpp
    #pragma once

    #include <cstddef>
    #include <cstdint>
    #include <new>
    #include "freertos/FreeRTOS.h"
    #include "freertos/portmacro.h"

    namespace RNS {

    /**
     * Fixed-size object pool with O(1) allocate/deallocate.
     * Thread-safe via spinlock. Falls back to nullptr on exhaustion.
     *
     * Template parameters:
     *   T - Object type to pool
     *   N - Pool capacity (number of slots)
     *
     * Usage:
     *   ObjectPool<MyClass, 16> pool;
     *   MyClass* obj = pool.allocate();  // nullptr if exhausted
     *   pool.deallocate(obj);
     */
    template <typename T, size_t N>
    class ObjectPool {
    public:
        ObjectPool() : _first_free(0), _allocated_count(0) {
            portMUX_INITIALIZE(&_mux);
            // Initialize freelist chain
            for (size_t i = 0; i < N - 1; i++) {
                _slots[i].next_free = i + 1;
            }
            _slots[N - 1].next_free = INVALID_SLOT;
        }

        /**
         * Allocate object from pool.
         * Returns nullptr if pool exhausted (caller should fall back to heap).
         * Thread-safe.
         */
        T* allocate() {
            portENTER_CRITICAL(&_mux);
            if (_first_free == INVALID_SLOT) {
                portEXIT_CRITICAL(&_mux);
                return nullptr;  // Pool exhausted
            }
            size_t slot = _first_free;
            _first_free = _slots[slot].next_free;
            _allocated_count++;
            portEXIT_CRITICAL(&_mux);

            // Placement new to construct object
            return new (&_slots[slot].storage) T();
        }

        /**
         * Return object to pool.
         * Pointer must have been obtained from this pool's allocate().
         * Thread-safe.
         */
        void deallocate(T* ptr) {
            if (!ptr) return;

            // Calculate slot index from pointer
            uintptr_t offset = reinterpret_cast<uintptr_t>(ptr) -
                              reinterpret_cast<uintptr_t>(_slots);
            size_t slot = offset / sizeof(Slot);

            if (slot >= N) {
                // Not from this pool - ignore (caller's responsibility)
                return;
            }

            // Explicit destructor call
            ptr->~T();

            portENTER_CRITICAL(&_mux);
            _slots[slot].next_free = _first_free;
            _first_free = slot;
            _allocated_count--;
            portEXIT_CRITICAL(&_mux);
        }

        /**
         * Check if pointer was allocated from this pool.
         */
        bool owns(T* ptr) const {
            if (!ptr) return false;
            uintptr_t start = reinterpret_cast<uintptr_t>(_slots);
            uintptr_t end = start + sizeof(_slots);
            uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
            return addr >= start && addr < end;
        }

        size_t allocated() const { return _allocated_count; }
        size_t capacity() const { return N; }
        size_t available() const { return N - _allocated_count; }

    private:
        static constexpr size_t INVALID_SLOT = ~size_t(0);

        struct Slot {
            union {
                alignas(T) char storage[sizeof(T)];
                size_t next_free;
            };
        };

        Slot _slots[N];
        size_t _first_free;
        size_t _allocated_count;
        portMUX_TYPE _mux;
    };

    } // namespace RNS
    ```

    Include guards against non-FreeRTOS builds (native) with preprocessor checks.
  </action>
  <verify>
    File exists and compiles: `pio run -e native` (may need stub for portMUX on native).
  </verify>
  <done>
    ObjectPool.h provides thread-safe fixed-size pool with freelist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add inline buffers to Packet::Object</name>
  <files>src/Packet.h</files>
  <action>
    Modify the Packet::Object class (around line 283) to use inline buffers for fixed-size fields:

    Replace:
    ```cpp
    Bytes _packet_hash;
    Bytes _ratchet_id;
    Bytes _destination_hash;
    Bytes _transport_id;
    ```

    With:
    ```cpp
    // Inline buffers for fixed-size fields (saves ~96 bytes per packet)
    // These fields have known maximum sizes from Type.h constants
    uint8_t _packet_hash_buf[32];       // SHA256 hash
    uint8_t _packet_hash_len = 0;

    uint8_t _ratchet_id_buf[32];        // Ratchet ID
    uint8_t _ratchet_id_len = 0;

    uint8_t _destination_hash_buf[16];  // Type::Reticulum::DESTINATION_LENGTH
    uint8_t _destination_hash_len = 0;

    uint8_t _transport_id_buf[16];      // Type::Reticulum::DESTINATION_LENGTH
    uint8_t _transport_id_len = 0;
    ```

    Add helper methods to the Packet class to get/set these as Bytes views:
    ```cpp
    // Inline buffer accessors - return Bytes view without allocation
    inline Bytes packet_hash() const {
        assert(_object);
        if (_object->_packet_hash_len == 0) return Bytes();
        return Bytes(_object->_packet_hash_buf, _object->_packet_hash_len);
    }
    inline void packet_hash(const Bytes& hash) {
        assert(_object);
        size_t len = std::min(hash.size(), sizeof(_object->_packet_hash_buf));
        memcpy(_object->_packet_hash_buf, hash.data(), len);
        _object->_packet_hash_len = len;
    }
    ```

    Repeat pattern for ratchet_id, destination_hash, transport_id.

    Keep the variable-size Bytes members unchanged:
    - _raw, _data, _plaintext, _header, _ciphertext
  </action>
  <verify>
    1. Packet.h compiles without errors
    2. Grep confirms inline buffers: `grep "_packet_hash_buf" src/Packet.h`
    3. No remaining `Bytes _packet_hash;` line
  </verify>
  <done>
    Packet::Object uses inline buffers for 4 fixed-size fields.
    Saves ~96 bytes overhead per packet (4 fields x 24 bytes Bytes overhead).
  </done>
</task>

<task type="auto">
  <name>Task 3: Document Bytes pool integration as future work</name>
  <files>src/Bytes.h</files>
  <action>
    Add documentation comment in Bytes.h noting pool integration as future optimization.

    DECISION: Bytes pool integration is DEFERRED. Rationale:
    - Pooling std::vector is complex due to variable size semantics
    - The inline buffers in Task 2 provide the majority of memory savings (~96 bytes/packet)
    - ObjectPool template (Task 1) provides infrastructure for future use
    - Integration surface area is large (affects COW semantics, PSRAMAllocator interaction)

    Implementation:
    Add comment block near the top of Bytes.h (after includes, before class):

    ```cpp
    // FUTURE OPTIMIZATION: Pool-backed Bytes allocation (MEM-H1)
    //
    // ObjectPool.h provides infrastructure for fixed-size pools.
    // Full Bytes pool integration deferred due to:
    //   1. Variable-size std::vector semantics don't map cleanly to fixed pools
    //   2. Inline buffers in Packet::Object (MEM-H3) provide majority of savings
    //   3. PSRAMAllocator interaction requires careful design
    //
    // If implemented later:
    //   - Pool fixed-size byte arrays (256, 512 bytes) for common packet sizes
    //   - Try pool in exclusiveData() COW path, fall back to make_shared
    //   - See ObjectPool.h for thread-safe pool template
    ```
  </action>
  <verify>
    1. Grep for "FUTURE OPTIMIZATION" in src/Bytes.h - should exist
    2. Build succeeds: `pio run -e native`
  </verify>
  <done>
    Bytes pool integration documented as future optimization with clear rationale for deferral.
  </done>
</task>

</tasks>

<verification>
1. `ls src/ObjectPool.h` confirms pool template exists
2. `grep "_packet_hash_buf" src/Packet.h` confirms inline buffers
3. Native build compiles: `pio run -e native`
4. T-Deck build compiles (if environment available): `pio run -e tdeck`
</verification>

<success_criteria>
- MEM-H3 complete: Packet inline buffers save ~96 bytes per packet
- MEM-H2 infrastructure: ObjectPool template created (Packet::Object pooling is future work - too much surface area for this phase)
- MEM-H1 deferred: Bytes pool documented as future optimization (inline buffers provide majority of savings)
- Thread-safe pool implementation with spinlock protection
</success_criteria>

<output>
After completion, create `.planning/phases/08-p3-optimization-hardening/08-04-SUMMARY.md`
</output>
