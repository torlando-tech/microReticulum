---
phase: 08-p3-optimization-hardening
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - src/BLE/platforms/NimBLEPlatform.cpp
  - src/BLE/platforms/NimBLEPlatform.h
autonomous: true

must_haves:
  truths:
    - "BLE shutdown waits up to 10 seconds for active write operations"
    - "Timeout triggers forced close with unclean shutdown flag"
    - "Graceful shutdown applies to all restart scenarios"
    - "Soft reset fully releases NimBLE state or uses hard recovery"
  artifacts:
    - path: "src/BLE/platforms/NimBLEPlatform.cpp"
      provides: "Graceful shutdown with timeout"
      pattern: "SHUTDOWN_TIMEOUT_MS|hasActiveWriteOperations"
    - path: "src/BLE/platforms/NimBLEPlatform.h"
      provides: "Unclean shutdown flag"
      pattern: "_unclean_shutdown"
  key_links:
    - from: "src/BLE/platforms/NimBLEPlatform.cpp"
      to: "NimBLEDevice::deinit"
      via: "Graceful shutdown before deinit"
      pattern: "shutdown.*deinit|waitForOperations"
---

<objective>
Implement graceful BLE shutdown that waits for active operations before NimBLE deinit.

Purpose: Complete CONC-H4 (BLE shutdown safety) and CONC-M4 (soft reset NimBLE release) to prevent use-after-free on restart and heap corruption from async callbacks.

Output: BLE subsystem waits up to 10 seconds for write operations before shutdown. Timeout sets unclean flag for boot verification.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-p3-optimization-hardening/08-RESEARCH.md

# Source files
@src/BLE/platforms/NimBLEPlatform.cpp
@src/BLE/platforms/NimBLEPlatform.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unclean shutdown flag and write tracking</name>
  <files>src/BLE/platforms/NimBLEPlatform.h</files>
  <action>
    Add the following to NimBLEPlatform class:

    1. Unclean shutdown flag (use RTC_NOINIT for persistence across soft reboot):
    ```cpp
    // BLE shutdown state tracking
    static bool _unclean_shutdown;  // Set if forced shutdown occurred

    // Active write operation tracking
    std::atomic<int> _active_write_count{0};
    ```

    2. Helper methods:
    ```cpp
    public:
        /**
         * Check if there are active write operations in progress.
         * Write operations are critical - interrupting can corrupt peer state.
         */
        bool hasActiveWriteOperations() const { return _active_write_count > 0; }

        /**
         * Check if last shutdown was clean.
         * Returns false if BLE was force-closed with active operations.
         */
        static bool wasCleanShutdown() { return !_unclean_shutdown; }

        /**
         * Clear unclean shutdown flag (call after boot verification).
         */
        static void clearUncleanShutdownFlag() { _unclean_shutdown = false; }

    private:
        /**
         * Mark a write operation as starting (call before characteristic write).
         */
        void beginWriteOperation() { _active_write_count++; }

        /**
         * Mark a write operation as complete (call after write callback).
         */
        void endWriteOperation() { _active_write_count--; }
    ```

    3. Static initialization in .cpp:
    ```cpp
    // In NimBLEPlatform.cpp
    RTC_NOINIT_ATTR bool NimBLEPlatform::_unclean_shutdown = false;
    ```

    Note: If RTC_NOINIT_ATTR is not available on all platforms, use regular static with comment.
  </action>
  <verify>
    Grep for `_unclean_shutdown` and `_active_write_count` in header.
  </verify>
  <done>
    Unclean shutdown flag and write operation tracking added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement graceful shutdown with timeout</name>
  <files>src/BLE/platforms/NimBLEPlatform.cpp</files>
  <action>
    Create a new `shutdown()` method and modify existing stop/cleanup logic.

    1. Add shutdown method (call this from all restart paths):
    ```cpp
    void NimBLEPlatform::shutdown() {
        INFO("NimBLEPlatform: Beginning graceful shutdown");

        const uint32_t SHUTDOWN_TIMEOUT_MS = 10000;
        uint32_t start = millis();

        // Stop accepting new operations
        transitionGAPState(GAPState::READY, GAPState::TRANSITIONING);

        // Wait for active write operations to complete
        while (hasActiveWriteOperations() && (millis() - start) < SHUTDOWN_TIMEOUT_MS) {
            DEBUG("NimBLEPlatform: Waiting for " + std::to_string(_active_write_count) +
                  " active write operation(s)");
            delay(100);  // Check every 100ms
        }

        // Check if we timed out
        if (hasActiveWriteOperations()) {
            WARNING("NimBLEPlatform: Shutdown timeout (" +
                    std::to_string(SHUTDOWN_TIMEOUT_MS) + "ms) with " +
                    std::to_string(_active_write_count.load()) + " active writes - forcing close");
            _unclean_shutdown = true;
        } else {
            DEBUG("NimBLEPlatform: All operations complete, proceeding with clean shutdown");
        }

        // Stop advertising and scanning
        stop();

        // Disconnect and cleanup clients
        {
            // Acquire connection mutex for cleanup
            if (xSemaphoreTake(_conn_mutex, pdMS_TO_TICKS(1000))) {
                for (auto& kv : _clients) {
                    if (kv.second) {
                        NimBLEDevice::deleteClient(kv.second);
                    }
                }
                _clients.clear();
                _connections.clear();
                _discovered_devices.clear();
                _discovered_order.clear();
                xSemaphoreGive(_conn_mutex);
            } else {
                WARNING("NimBLEPlatform: Could not acquire mutex for cleanup");
            }
        }

        // Deinit NimBLE stack
        if (_initialized) {
            NimBLEDevice::deinit(true);
            _initialized = false;
        }

        INFO("NimBLEPlatform: Shutdown complete" +
             std::string(wasCleanShutdown() ? "" : " (unclean - verify on boot)"));
    }
    ```

    2. Call shutdown() from all restart paths:
    - Find existing `stop()` calls followed by `deinit()`
    - Replace with `shutdown()` call
    - Ensure OTA update path, user restart, and watchdog recovery all use shutdown()

    3. Wrap write operations with begin/end tracking:
    - In characteristic write methods, call `beginWriteOperation()` before write
    - In write callback/completion, call `endWriteOperation()`
    - Use RAII pattern if possible (WriteGuard class)
  </action>
  <verify>
    1. Grep for `shutdown()` method definition
    2. Grep for `SHUTDOWN_TIMEOUT_MS` constant
    3. Build compiles successfully
  </verify>
  <done>
    Graceful shutdown waits 10s for writes, sets unclean flag on timeout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance soft reset for complete NimBLE state release</name>
  <files>src/BLE/platforms/NimBLEPlatform.cpp</files>
  <action>
    Examine and enhance the existing soft reset logic (around line 1040-1080).

    The current soft reset may not fully release NimBLE state. Enhance to:

    1. Call `shutdown()` as first step of reset
    2. Wait for NimBLE host task to quiesce
    3. If soft reset fails, fall back to hard recovery:

    ```cpp
    bool NimBLEPlatform::softReset() {
        INFO("NimBLEPlatform: Soft reset requested");

        // Use graceful shutdown first
        shutdown();

        // Brief delay for NimBLE host task to process shutdown
        delay(100);

        // Reinitialize
        if (!init()) {
            WARNING("NimBLEPlatform: Soft reset failed, attempting hard recovery");
            // Hard recovery: ESP restart as last resort
            // Don't actually restart here - return false and let caller decide
            return false;
        }

        INFO("NimBLEPlatform: Soft reset complete");
        return true;
    }
    ```

    Update the existing reset functions to use this enhanced pattern.

    If softReset fails:
    - Log detailed state for debugging
    - Return false to caller
    - Caller (Transport or main) can decide to trigger ESP.restart() if needed
  </action>
  <verify>
    1. Grep for `softReset` method to confirm enhancement
    2. Verify shutdown() is called in reset path
    3. Build compiles successfully
  </verify>
  <done>
    Soft reset uses graceful shutdown and has hard recovery fallback path.
  </done>
</task>

</tasks>

<verification>
1. `grep -n "shutdown()" src/BLE/platforms/NimBLEPlatform.cpp` shows method exists
2. `grep -n "SHUTDOWN_TIMEOUT_MS" src/BLE/platforms/NimBLEPlatform.cpp` shows constant
3. `grep -n "_unclean_shutdown" src/BLE/platforms/NimBLEPlatform.h` shows flag
4. Native build compiles: `pio run -e native`
5. (If available) T-Deck build compiles: `pio run -e tdeck`
</verification>

<success_criteria>
- CONC-H4 complete: BLE shutdown waits 10s for write operations
- CONC-M4 complete: Soft reset fully releases NimBLE state
- Timeout sets unclean shutdown flag for boot verification
- All restart paths (user, OTA, watchdog) use graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/08-p3-optimization-hardening/08-05-SUMMARY.md`
</output>
