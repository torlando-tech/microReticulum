---
phase: 08-p3-optimization-hardening
plan: 08
type: execute
wave: 5
depends_on: ["08-06", "08-07"]
files_modified:
  - src/BytesPool.h
  - src/Bytes.cpp
  - src/Packet.cpp
  - src/ObjectPool.h
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Pool exhaustion logs WARNING with pool stats"
    - "Heap allocation failure is caught and logged as ERROR"
    - "Packet/Bytes return gracefully on allocation failure (no crash)"
    - "Pool stats track fallback count for monitoring"
  artifacts:
    - path: "src/Bytes.cpp"
      provides: "WARNING on pool fallback, try/catch on heap alloc"
      pattern: "WARNING.*pool|catch.*bad_alloc"
    - path: "src/Packet.cpp"
      provides: "WARNING on pool fallback, try/catch on heap alloc"
      pattern: "WARNING.*pool|catch.*bad_alloc"
    - path: "src/BytesPool.h"
      provides: "Fallback counter in stats"
      contains: "_fallback_count"
  key_links: []
---

<objective>
Add visibility and graceful failure handling for pool exhaustion and heap allocation failures.

Purpose: For headless ESP32 running months/years in remote locations, silent failures are unacceptable. Operators need visibility into pool behavior, and allocation failures must not crash the device.

Output: WARNING logs on pool fallback, ERROR logs on heap failure, graceful degradation instead of crash.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

# Source files
@src/BytesPool.h
@src/Bytes.cpp
@src/Packet.cpp
@src/ObjectPool.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fallback counter and WARNING to BytesPool</name>
  <files>src/BytesPool.h</files>
  <action>
    Add fallback tracking to BytesPool:

    1. Add counter member:
    ```cpp
    size_t _fallback_count = 0;  // Heap fallbacks due to pool exhaustion
    ```

    2. Add accessor:
    ```cpp
    size_t fallback_count() const { return _fallback_count; }
    ```

    3. Update logStats() to include fallback count:
    ```cpp
    INFO("BytesPool: ... fallbacks=" + std::to_string(_fallback_count) + ...);
    ```

    4. Add a method to log warning on fallback (called by Bytes.cpp):
    ```cpp
    void recordFallback(size_t requested_size) {
        _fallback_count++;
        WARNING("BytesPool: exhausted, falling back to heap (requested=" +
                std::to_string(requested_size) + " bytes, " +
                "small=" + std::to_string(small_allocated()) + "/" + std::to_string(BytesPoolConfig::SLOTS_PER_TIER) +
                " med=" + std::to_string(medium_allocated()) + "/" + std::to_string(BytesPoolConfig::SLOTS_PER_TIER) +
                " large=" + std::to_string(large_allocated()) + "/" + std::to_string(BytesPoolConfig::SLOTS_PER_TIER) + ")");
    }
    ```

    Note: Include Log.h at top of file for WARNING macro.
  </action>
  <verify>
    grep "fallback_count" src/BytesPool.h
    grep "WARNING.*exhausted" src/BytesPool.h
  </verify>
  <done>
    BytesPool tracks and logs fallback events with pool state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WARNING and try/catch to Bytes.cpp</name>
  <files>src/Bytes.cpp</files>
  <action>
    Update newData() and exclusiveData() to:

    1. Log warning when pool exhausted (call BytesPool::recordFallback):

    In newData() around line 25:
    ```cpp
    // Pool exhausted - fall through to make_shared
    BytesPool::instance().recordFallback(capacity);
    ```

    In exclusiveData() around line 75:
    ```cpp
    // Pool exhausted - fall through to make_shared
    BytesPool::instance().recordFallback(required_capacity);
    ```

    2. Wrap heap allocation in try/catch:

    In newData() around line 29:
    ```cpp
    // Fallback: standard allocation for oversized or when pool exhausted
    try {
        _data = std::make_shared<Data>();
    } catch (const std::bad_alloc& e) {
        ERROR("Bytes::newData heap allocation failed: " + std::string(e.what()));
        _data = nullptr;
        _exclusive = false;
        return;  // Caller must check if _data is valid
    }
    ```

    In exclusiveData() similar pattern for make_shared calls.

    3. Remove the throw std::runtime_error - instead return with _data = nullptr
       Caller can check isEmpty() or _data validity.
  </action>
  <verify>
    grep "recordFallback" src/Bytes.cpp
    grep "catch.*bad_alloc" src/Bytes.cpp
  </verify>
  <done>
    Bytes logs WARNING on pool fallback, catches heap failures gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WARNING and try/catch to Packet.cpp</name>
  <files>src/Packet.cpp, src/Packet.h</files>
  <action>
    Update Packet and PacketReceipt constructors to log and handle failures:

    1. Add fallback tracking to Packet class (in Packet.h):
    ```cpp
    // Pool statistics
    static size_t _pool_fallback_count;
    static size_t poolFallbackCount() { return _pool_fallback_count; }
    ```

    2. In Packet.cpp, add static member:
    ```cpp
    size_t Packet::_pool_fallback_count = 0;
    ```

    3. Update Packet constructor (around line 41):
    ```cpp
    Object* obj = objectPool().allocate(destination, attached_interface);
    if (obj) {
        _object = std::shared_ptr<Object>(obj, PacketObjectDeleter{true});
    } else {
        // Pool exhausted - log and fall back to heap
        _pool_fallback_count++;
        WARNING("PacketObjectPool: exhausted, falling back to heap (allocated=" +
                std::to_string(objectPool().allocated()) + "/" +
                std::to_string(PACKET_OBJECT_POOL_SIZE) + ")");
        try {
            _object = std::shared_ptr<Object>(new Object(destination, attached_interface), PacketObjectDeleter{false});
        } catch (const std::bad_alloc& e) {
            ERROR("Packet heap allocation failed: " + std::string(e.what()));
            _object = nullptr;
            return;  // Caller must check _object validity
        }
    }
    ```

    4. Same pattern for PacketReceipt constructor and ensure_object().

    5. Add check at start of methods that use _object:
    ```cpp
    if (!_object) {
        ERROR("Packet operation on null object");
        return;  // or appropriate error handling
    }
    ```
  </action>
  <verify>
    grep "WARNING.*PacketObjectPool" src/Packet.cpp
    grep "catch.*bad_alloc" src/Packet.cpp
    grep "_pool_fallback_count" src/Packet.cpp
  </verify>
  <done>
    Packet logs WARNING on pool fallback, catches heap failures gracefully.
  </done>
</task>

</tasks>

<verification>
1. grep "WARNING.*exhausted\|WARNING.*Pool" src/BytesPool.h src/Bytes.cpp src/Packet.cpp
2. grep "catch.*bad_alloc" src/Bytes.cpp src/Packet.cpp
3. grep "fallback_count\|_pool_fallback_count" src/BytesPool.h src/Packet.cpp
4. pio run -e native (verify compilation)
</verification>

<success_criteria>
- Pool exhaustion logs WARNING with current pool state (visibility for tuning)
- Heap allocation failures caught with ERROR log (no std::bad_alloc crash)
- Fallback count tracked in stats (monitoring for pool sizing)
- No crashes on allocation failure - graceful degradation
</success_criteria>

<output>
After completion, create `.planning/phases/08-p3-optimization-hardening/08-08-SUMMARY.md`
</output>
