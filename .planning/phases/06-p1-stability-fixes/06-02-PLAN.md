---
phase: 06-p1-stability-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/lxmf_tdeck/sdkconfig.defaults
  - src/UI/LVGL/LVGLInit.cpp
  - src/LXMF/LXStamper.cpp
  - examples/common/ble_interface/BLEInterface.cpp
autonomous: true

must_haves:
  truths:
    - "Task starvation and deadlocks are detected by watchdog timer"
    - "UI remains responsive during stamp generation operations"
    - "Concurrent BLE operations execute without race conditions or crashes"
  artifacts:
    - path: "examples/lxmf_tdeck/sdkconfig.defaults"
      provides: "TWDT configuration"
      contains: "CONFIG_ESP_TASK_WDT_EN=y"
    - path: "src/UI/LVGL/LVGLInit.cpp"
      provides: "LVGL task TWDT subscription"
      contains: "esp_task_wdt_add"
    - path: "src/LXMF/LXStamper.cpp"
      provides: "Improved yield frequency"
      contains: "rounds % 10"
    - path: "examples/common/ble_interface/BLEInterface.cpp"
      provides: "Mutex-protected callback queues"
      contains: "lock_guard.*_mutex"
  key_links:
    - from: "examples/lxmf_tdeck/sdkconfig.defaults"
      to: "src/UI/LVGL/LVGLInit.cpp"
      via: "TWDT config enables watchdog API"
      pattern: "CONFIG_ESP_TASK_WDT"
    - from: "src/LXMF/LXStamper.cpp"
      to: "esp_task_wdt_reset()"
      via: "watchdog reset during yields"
      pattern: "esp_task_wdt_reset"
---

<objective>
Fix critical concurrency issues: enable Task Watchdog Timer, improve LXStamper yield frequency, and protect BLE pending queues with mutex.

Purpose: Eliminate task starvation, UI freezes during stamp generation, and race conditions in BLE callbacks - three P1 stability issues with WSJF scores of 3.5 each.

Output: Watchdog-protected tasks with cooperative yielding and thread-safe queue access.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-p1-stability-fixes/06-RESEARCH.md
@examples/lxmf_tdeck/sdkconfig.defaults
@src/UI/LVGL/LVGLInit.cpp
@src/LXMF/LXStamper.cpp
@examples/common/ble_interface/BLEInterface.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable Task Watchdog Timer (TWDT) in sdkconfig</name>
  <files>examples/lxmf_tdeck/sdkconfig.defaults</files>
  <action>
Add TWDT configuration to sdkconfig.defaults after the Boot Time Optimizations section (after line 70):

```
# ============================================================================
# Task Watchdog Timer (TWDT)
# Detects task starvation and deadlock conditions
# ============================================================================
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_TIMEOUT_S=10
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1=y
```

The 10-second timeout provides enough margin for CPU-intensive operations (crypto, JSON) while still detecting genuine hangs.
  </action>
  <verify>
- Verify config added: `grep "ESP_TASK_WDT" examples/lxmf_tdeck/sdkconfig.defaults`
- Should show 4 CONFIG lines for TWDT
  </verify>
  <done>
TWDT configuration added with 10s timeout and idle task monitoring on both cores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Subscribe LVGL task to TWDT and add watchdog reset</name>
  <files>src/UI/LVGL/LVGLInit.cpp</files>
  <action>
1. Add include at top of file (after existing includes):
   ```cpp
   #include "esp_task_wdt.h"
   ```

2. Modify the lvgl_task function (around line 152) to subscribe and reset watchdog:
   ```cpp
   void LVGLInit::lvgl_task(void* param) {
       Serial.printf("LVGL task started on core %d\n", xPortGetCoreID());

       // Subscribe this task to Task Watchdog Timer
       esp_task_wdt_add(nullptr);  // nullptr = current task

       while (true) {
           // Acquire mutex before calling LVGL
           if (xSemaphoreTakeRecursive(_mutex, portMAX_DELAY) == pdTRUE) {
               lv_task_handler();
               xSemaphoreGiveRecursive(_mutex);
           }

           // Feed watchdog and yield to other tasks
           esp_task_wdt_reset();
           vTaskDelay(pdMS_TO_TICKS(5));
       }
   }
   ```

The key changes:
- Add `esp_task_wdt_add(nullptr)` after task startup message
- Add `esp_task_wdt_reset()` before the vTaskDelay call
  </action>
  <verify>
- Verify include added: `grep "esp_task_wdt.h" src/UI/LVGL/LVGLInit.cpp`
- Verify subscription: `grep "esp_task_wdt_add" src/UI/LVGL/LVGLInit.cpp`
- Verify reset: `grep "esp_task_wdt_reset" src/UI/LVGL/LVGLInit.cpp`
  </verify>
  <done>
LVGL task subscribes to TWDT on startup and resets watchdog in main loop.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix LXStamper yield frequency and add watchdog reset</name>
  <files>src/LXMF/LXStamper.cpp</files>
  <action>
1. Add include at top of file (after existing includes, within ESP_PLATFORM guard or near it):
   ```cpp
   #ifdef ESP_PLATFORM
   #include "esp_task_wdt.h"
   #endif
   ```

2. Modify the yield block (around line 192-198):

   Find:
   ```cpp
   // Yield to allow other tasks (LVGL, network) to run
   // This prevents UI freeze during stamp generation
   #ifdef ESP_PLATFORM
       if (rounds % 100 == 0) {
           vTaskDelay(1);  // Yield for 1 tick
       }
   #endif
   ```

   Replace with:
   ```cpp
   // Yield to allow other tasks (LVGL, network) to run
   // This prevents UI freeze during stamp generation
   // Yield every 10 rounds (was 100) for better UI responsiveness
   #ifdef ESP_PLATFORM
       if (rounds % 10 == 0) {
           vTaskDelay(1);        // Yield for 1 tick
           esp_task_wdt_reset(); // Feed watchdog during long operations
       }
   #endif
   ```

This increases yield frequency 10x and adds watchdog feeding to prevent timeouts during stamp generation.
  </action>
  <verify>
- Verify include added: `grep "esp_task_wdt.h" src/LXMF/LXStamper.cpp`
- Verify yield frequency changed: `grep "rounds % 10" src/LXMF/LXStamper.cpp`
- Verify watchdog reset added: `grep "esp_task_wdt_reset" src/LXMF/LXStamper.cpp`
  </verify>
  <done>
LXStamper yields every 10 rounds (10x more frequent) and resets watchdog during stamp generation.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add mutex protection to BLE pending queues</name>
  <files>examples/common/ble_interface/BLEInterface.cpp</files>
  <action>
Add lock_guard to callback functions that modify _pending_handshakes and _pending_data:

1. Find `onHandshakeComplete` function (around line 641) and add mutex lock at start:
   ```cpp
   void BLEInterface::onHandshakeComplete(const Bytes& mac, const Bytes& identity, bool is_central) {
       // ADDED: Lock before modifying queue - protects against race with loop()
       std::lock_guard<std::recursive_mutex> lock(_mutex);

       // Queue the handshake for processing in loop() to avoid stack overflow in NimBLE callback
       // The NimBLE task has limited stack space, so we defer heavy processing
       if (_pending_handshakes.size() >= MAX_PENDING_HANDSHAKES) {
   ```
   (rest of function unchanged)

2. Find the section that pushes to _pending_data (around line 866-874) and add mutex lock.
   The code block starting with `if (_pending_data.size() >= MAX_PENDING_DATA)` needs a lock_guard before it.

   This is in the `handleIncomingDataDeferred` or similar function. Add:
   ```cpp
   // ADDED: Lock before modifying queue - protects against race with loop()
   std::lock_guard<std::recursive_mutex> lock(_mutex);

   if (_pending_data.size() >= MAX_PENDING_DATA) {
   ```

Note: The mutex is `std::recursive_mutex _mutex` and is already declared in the class.
Note: Use `std::lock_guard<std::recursive_mutex>` for RAII-style locking.
  </action>
  <verify>
- Verify lock in onHandshakeComplete: `grep -A5 "onHandshakeComplete.*mac.*identity" examples/common/ble_interface/BLEInterface.cpp | grep lock_guard`
- Verify lock before _pending_data access: Check that lock_guard appears before _pending_data.push_back operations
- Compile the project: `pio run -e tdeck_plus`
  </verify>
  <done>
Both onHandshakeComplete and _pending_data write paths protected by _mutex lock_guard.
  </done>
</task>

</tasks>

<verification>
1. Full build succeeds: `pio run -e tdeck_plus`
2. TWDT config present in sdkconfig.defaults
3. LVGL task subscribes to TWDT and resets it in loop
4. LXStamper yields every 10 rounds (not 100) and resets watchdog
5. BLE callback functions acquire mutex before modifying pending queues
</verification>

<success_criteria>
- CONC-01: TWDT enabled with 10s timeout, LVGL task subscribed
- CONC-02: LXStamper yields 10x more frequently (every 10 rounds) with watchdog reset
- CONC-03: BLE pending queues protected by mutex in callback paths
- Build completes cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-p1-stability-fixes/06-02-SUMMARY.md`
</output>
