---
phase: 04-concurrency-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/04-concurrency-audit/04-LVGL.md
autonomous: true

must_haves:
  truths:
    - "All LVGL API calls in src/UI/ are audited for mutex protection"
    - "Event handler threading context is documented"
    - "LVGL_LOCK() usage patterns are evaluated for RAII correctness"
    - "Any unprotected LVGL calls are identified with severity rating"
  artifacts:
    - path: ".planning/phases/04-concurrency-audit/04-LVGL.md"
      provides: "LVGL thread safety audit report"
      contains: "## Mutex Protection Audit"
  key_links:
    - from: "04-LVGL.md"
      to: "CONC-01 requirement"
      via: "audit of all lv_* calls"
      pattern: "LVGL_LOCK\\(\\)|lv_"
---

<objective>
Audit all LVGL API usage in the codebase for thread safety compliance.

Purpose: Document whether all LVGL calls from outside the LVGL task are properly protected by LVGL_LOCK(), and identify any threading risks in event handlers or callbacks.

Output: `.planning/phases/04-concurrency-audit/04-LVGL.md` with complete audit results.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-concurrency-audit/04-CONTEXT.md
@.planning/phases/04-concurrency-audit/04-RESEARCH.md

Key files to audit:
- src/UI/LVGL/LVGLInit.cpp/h - Task and mutex creation
- src/UI/LVGL/LVGLLock.h - Lock abstraction (RAII wrapper)
- src/UI/LXMF/UIManager.cpp - Main UI controller with callbacks
- src/UI/LXMF/*.cpp - All screen implementations

Research findings:
- LVGL runs on its own FreeRTOS task (core 1, priority 2)
- Recursive mutex used (xSemaphoreCreateRecursiveMutex)
- LVGL_LOCK() macro provides RAII-style locking
- portMAX_DELAY used for mutex acquisition
- 60+ lock sites found across UIManager and screens
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit LVGL_LOCK() coverage across all UI files</name>
  <files>
    src/UI/LVGL/LVGLInit.cpp
    src/UI/LVGL/LVGLInit.h
    src/UI/LVGL/LVGLLock.h
    src/UI/LXMF/UIManager.cpp
    src/UI/LXMF/StatusScreen.cpp
    src/UI/LXMF/SettingsScreen.cpp
    src/UI/LXMF/ChatScreen.cpp
    src/UI/LXMF/ConversationListScreen.cpp
    src/UI/LXMF/ComposeScreen.cpp
    src/UI/LXMF/AnnounceListScreen.cpp
    src/UI/LXMF/PropagationNodesScreen.cpp
    src/UI/LXMF/QRScreen.cpp
  </files>
  <action>
    1. Read LVGLInit.cpp/h to document the LVGL task creation and mutex setup
    2. Read LVGLLock.h to understand the RAII lock pattern
    3. For EACH screen file in src/UI/LXMF/:
       a. Find all lv_* function calls (grep for pattern)
       b. Verify each call site has LVGL_LOCK() in scope
       c. Document any calls NOT protected by LVGL_LOCK()
       d. Note whether call is in constructor, method, or event callback
    4. Create categorized findings:
       - Protected calls (with LVGL_LOCK())
       - Event handlers (running in LVGL context - no lock needed)
       - Potentially unprotected calls (need investigation)

    Severity ratings per 04-CONTEXT.md:
    - Critical = crash or data corruption
    - High = deadlock risk
    - Medium = race condition potential
    - Low = code smell / best practice violation
  </action>
  <verify>Grep for lv_ calls and LVGL_LOCK usage, confirm all non-callback lv_* calls have lock protection</verify>
  <done>Complete inventory of lv_* call sites with protection status documented</done>
</task>

<task type="auto">
  <name>Task 2: Analyze event handler threading context</name>
  <files>
    src/UI/LXMF/UIManager.cpp
    src/UI/LXMF/*.cpp (all screens)
  </files>
  <action>
    1. Find all LVGL event callbacks (lv_obj_add_event_cb patterns)
    2. Document what context each callback runs in:
       - LVGL task context (already holds mutex, safe to call lv_* directly)
       - Main task context (needs LVGL_LOCK())
       - Other contexts (BLE callback, timer callback - danger)
    3. Check for any callbacks that might:
       - Block for long periods (portMAX_DELAY waits on other resources)
       - Call non-thread-safe code from LVGL context
       - Access shared state without proper synchronization
    4. Document any callbacks that update UI from non-LVGL tasks
    5. Include 3-5 line code snippets showing problematic patterns (per 04-CONTEXT.md)
  </action>
  <verify>All event callback sites are documented with threading context analysis</verify>
  <done>Event handler threading model fully documented with any risks identified</done>
</task>

<task type="auto">
  <name>Task 3: Create 04-LVGL.md audit report</name>
  <files>.planning/phases/04-concurrency-audit/04-LVGL.md</files>
  <action>
    Create comprehensive audit report with sections:

    1. **Executive Summary** - Overall LVGL thread safety status, issue count by severity
    2. **Threading Model** - How LVGL task works, mutex type, lock pattern
    3. **Mutex Protection Audit** - Table of all files with lv_* call counts and lock coverage
    4. **Event Handler Analysis** - Callback threading contexts and patterns
    5. **Findings** - Each issue with:
       - Severity (Critical/High/Medium/Low)
       - Location (file:line or function)
       - Description
       - Code snippet (3-5 lines)
       - Recommended fix
    6. **Positive Patterns** - Good practices found (RAII locking, etc.)
    7. **ASCII Diagram** - LVGL task and mutex relationship

    Include cross-reference to CONC-01 requirement.
  </action>
  <verify>File exists with all required sections, issue table, and ASCII diagram</verify>
  <done>04-LVGL.md contains complete LVGL thread safety audit with severity-rated findings</done>
</task>

</tasks>

<verification>
1. All lv_* calls in src/UI/ are inventoried with protection status
2. Event handlers have documented threading context
3. Any unprotected calls are flagged with severity
4. 04-LVGL.md exists with complete audit results
5. ASCII diagram shows task/mutex relationship
</verification>

<success_criteria>
- 04-LVGL.md exists with Executive Summary, Threading Model, Mutex Protection Audit, Event Handler Analysis, Findings, and diagram
- All src/UI/**/*.cpp files are audited
- Each finding has severity rating and recommended fix
- CONC-01 requirement is addressed
</success_criteria>

<output>
After completion, create `.planning/phases/04-concurrency-audit/04-01-SUMMARY.md`
</output>
