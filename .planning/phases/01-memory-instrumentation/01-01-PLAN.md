---
phase: 01-memory-instrumentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Instrumentation/MemoryMonitor.h
  - src/Instrumentation/MemoryMonitor.cpp
autonomous: true

must_haves:
  truths:
    - "Heap statistics (free, largest block, min free) are logged for both internal RAM and PSRAM"
    - "Fragmentation percentage is calculated and logged"
    - "Task stack high water marks can be logged for registered tasks"
    - "All instrumentation code is wrapped in build flag guards"
  artifacts:
    - path: "src/Instrumentation/MemoryMonitor.h"
      provides: "Public API with build flag isolation"
      exports: ["MemoryMonitor class", "stub macros when disabled"]
    - path: "src/Instrumentation/MemoryMonitor.cpp"
      provides: "ESP32-specific implementation using heap_caps and FreeRTOS APIs"
      min_lines: 150
  key_links:
    - from: "src/Instrumentation/MemoryMonitor.cpp"
      to: "esp_heap_caps.h"
      via: "heap_caps_get_free_size, heap_caps_get_largest_free_block"
      pattern: "heap_caps_get_"
    - from: "src/Instrumentation/MemoryMonitor.cpp"
      to: "freertos/timers.h"
      via: "xTimerCreate for periodic logging"
      pattern: "xTimerCreate"
---

<objective>
Create the core MemoryMonitor module that provides heap/stack monitoring capabilities for ESP32-S3.

Purpose: Establish the foundation for runtime memory monitoring that captures baseline fragmentation data. This module will be used by the application to track memory health during extended operation.

Output: Two new files in src/Instrumentation/ that provide a complete memory monitoring API, isolated via MEMORY_INSTRUMENTATION_ENABLED build flag.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-memory-instrumentation/01-RESEARCH.md

# Existing patterns in codebase
@src/Log.h (build flag pattern with MEM_LOG)
@src/Utilities/OS.h (existing heap_available, heap_max_block)
@src/Utilities/OS.cpp (ESP32 heap APIs already used)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemoryMonitor header with build flag isolation</name>
  <files>src/Instrumentation/MemoryMonitor.h</files>
  <action>
Create new file src/Instrumentation/MemoryMonitor.h with:

1. Pragma once guard
2. Wrap entire class in `#ifdef MEMORY_INSTRUMENTATION_ENABLED`
3. Include required headers: esp_heap_caps.h, freertos/FreeRTOS.h, freertos/task.h, freertos/timers.h
4. Namespace: RNS::Instrumentation

Class MemoryMonitor (all static methods):
- `static bool init(uint32_t interval_ms = 30000)` - Initialize and start periodic monitoring
- `static void stop()` - Stop monitoring timer
- `static void registerTask(TaskHandle_t handle, const char* name)` - Add task to stack monitoring registry
- `static void unregisterTask(TaskHandle_t handle)` - Remove task from registry
- `static void setVerbose(bool verbose)` - Toggle detailed output (default false)
- `static void logNow()` - Trigger immediate log output (for debugging)

Private members:
- `static void timerCallback(TimerHandle_t timer)` - FreeRTOS timer callback
- `static void logHeapStats()` - Log heap metrics
- `static void logTaskStacks()` - Log task stack high water marks
- `static TimerHandle_t _timer`
- `static bool _verbose`

Outside ifdef block, provide stub macros for when disabled:
- `#define MEMORY_MONITOR_INIT(interval) ((void)0)`
- `#define MEMORY_MONITOR_REGISTER_TASK(handle, name) ((void)0)`
- `#define MEMORY_MONITOR_UNREGISTER_TASK(handle) ((void)0)`

Follow the existing Log.h pattern for conditional compilation (MEM_LOG example).
  </action>
  <verify>File exists and compiles: grep -l "MEMORY_INSTRUMENTATION_ENABLED" src/Instrumentation/MemoryMonitor.h</verify>
  <done>Header file exists with complete API declaration and build flag guards</done>
</task>

<task type="auto">
  <name>Task 2: Implement MemoryMonitor with ESP-IDF APIs</name>
  <files>src/Instrumentation/MemoryMonitor.cpp</files>
  <action>
Create new file src/Instrumentation/MemoryMonitor.cpp with:

1. Include MemoryMonitor.h
2. Guard entire implementation with `#ifdef MEMORY_INSTRUMENTATION_ENABLED`
3. Include Log.h for output (use existing RNS logging macros)

Task Registry (static storage):
- Define MAX_MONITORED_TASKS = 16
- Struct TaskEntry { TaskHandle_t handle; char name[configMAX_TASK_NAME_LEN]; }
- Static array _task_registry[MAX_MONITORED_TASKS]
- Static size_t _task_count = 0

Static members initialization:
- TimerHandle_t _timer = nullptr
- bool _verbose = false

Implement init(interval_ms):
- Create FreeRTOS software timer with xTimerCreate("mem_mon", pdMS_TO_TICKS(interval_ms), pdTRUE, nullptr, timerCallback)
- Start timer with xTimerStart
- Log initial heap stats immediately
- Return success/failure

Implement stop():
- If _timer not null, xTimerStop and xTimerDelete
- Set _timer to nullptr

Implement registerTask(handle, name):
- Check _task_count < MAX_MONITORED_TASKS
- Copy handle and name to _task_registry[_task_count]
- Increment _task_count
- Use strncpy for name, ensure null termination

Implement unregisterTask(handle):
- Find entry by handle
- Shift remaining entries to fill gap
- Decrement _task_count

Implement timerCallback(timer):
- Call logHeapStats()
- Call logTaskStacks()

Implement logHeapStats():
- Use heap_caps_get_free_size(MALLOC_CAP_INTERNAL) for internal RAM
- Use heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL) for largest block
- Use heap_caps_get_minimum_free_size(MALLOC_CAP_INTERNAL) for min free (watermark)
- Calculate fragmentation: (free > 0) ? (100 - (largest * 100 / free)) : 0
- Repeat for MALLOC_CAP_SPIRAM (PSRAM)
- Use static char buffer[256] for formatting (avoid stack allocation)
- Output via INFOF or NOTICEF (human-readable format per CONTEXT.md decisions)
- Format: "HEAP: int_free=N int_largest=N int_min=N int_frag=N% psram_free=N psram_largest=N"

Implement logTaskStacks():
- Iterate _task_registry up to _task_count
- For each task, call uxTaskGetStackHighWaterMark(handle)
- Multiply result by 4 (words to bytes on ESP32)
- Use static char buffer for formatting
- Output: "STACK: task1=N task2=N ..." (bytes remaining)

Implement setVerbose(verbose):
- Set _verbose flag
- When verbose, include additional metrics or more frequent output

Implement logNow():
- Call logHeapStats() and logTaskStacks() directly
  </action>
  <verify>File exists and has implementation: wc -l src/Instrumentation/MemoryMonitor.cpp should show 150+ lines</verify>
  <done>Implementation compiles and uses correct ESP-IDF heap_caps APIs and FreeRTOS timer APIs</done>
</task>

</tasks>

<verification>
1. Both files exist in src/Instrumentation/ directory
2. Header has proper build flag guards (#ifdef MEMORY_INSTRUMENTATION_ENABLED)
3. Implementation uses heap_caps_get_free_size, heap_caps_get_largest_free_block
4. Implementation uses xTimerCreate for periodic execution
5. Task registry uses static array (no dynamic allocation)
6. Stub macros provided for disabled builds
</verification>

<success_criteria>
- src/Instrumentation/MemoryMonitor.h and .cpp exist
- Code compiles when MEMORY_INSTRUMENTATION_ENABLED is defined
- Code compiles (as no-ops) when MEMORY_INSTRUMENTATION_ENABLED is NOT defined
- API matches RESEARCH.md patterns exactly (heap_caps, xTimerCreate, uxTaskGetStackHighWaterMark)
- No dynamic memory allocation in instrumentation code (static buffers only)
</success_criteria>

<output>
After completion, create `.planning/phases/01-memory-instrumentation/01-01-SUMMARY.md`
</output>
