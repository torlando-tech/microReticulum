---
phase: 01-memory-instrumentation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - examples/lxmf_tdeck/platformio.ini
  - examples/lxmf_tdeck/src/main.cpp
autonomous: true

must_haves:
  truths:
    - "Memory monitoring starts automatically when firmware boots (if build flag enabled)"
    - "LVGL task is registered with the memory monitor"
    - "Heap and stack stats are logged every 30 seconds to serial console"
    - "Build flag can be toggled in platformio.ini to enable/disable instrumentation"
  artifacts:
    - path: "examples/lxmf_tdeck/platformio.ini"
      provides: "MEMORY_INSTRUMENTATION_ENABLED build flag definition"
      contains: "-DMEMORY_INSTRUMENTATION_ENABLED"
    - path: "examples/lxmf_tdeck/src/main.cpp"
      provides: "MemoryMonitor initialization and task registration"
      contains: "MemoryMonitor::init"
  key_links:
    - from: "examples/lxmf_tdeck/src/main.cpp"
      to: "src/Instrumentation/MemoryMonitor.h"
      via: "include and init call in setup()"
      pattern: "#include.*MemoryMonitor"
    - from: "examples/lxmf_tdeck/src/main.cpp"
      to: "LVGLInit::_task_handle"
      via: "registerTask call after LVGL task starts"
      pattern: "registerTask.*lvgl"
---

<objective>
Integrate the MemoryMonitor into the T-Deck application and configure the build system.

Purpose: Enable memory monitoring in the actual firmware so baseline data can be captured during runtime. This completes the instrumentation phase by wiring the module into the application lifecycle.

Output: Modified platformio.ini with build flag, modified main.cpp with initialization and task registration.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-memory-instrumentation/01-RESEARCH.md
@.planning/phases/01-memory-instrumentation/01-01-SUMMARY.md

# Application code to modify
@examples/lxmf_tdeck/platformio.ini
@examples/lxmf_tdeck/src/main.cpp (focus on setup functions around line 480-500)

# LVGL task handle access
@src/UI/LVGL/LVGLInit.h (has static _task_handle)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build flag to platformio.ini</name>
  <files>examples/lxmf_tdeck/platformio.ini</files>
  <action>
Add the MEMORY_INSTRUMENTATION_ENABLED build flag to both tdeck environments.

For [env:tdeck] section, add to build_flags:
    -DMEMORY_INSTRUMENTATION_ENABLED

For [env:tdeck-bluedroid] section, add to build_flags:
    -DMEMORY_INSTRUMENTATION_ENABLED

Add a comment above each flag explaining its purpose:
    ; Enable memory instrumentation (heap/stack monitoring)
    ; Remove this flag to disable instrumentation and eliminate overhead

Place the flag near the end of build_flags so it's easy to find and toggle.

Note: The flag should be ENABLED by default during this audit phase. Users can comment it out to disable.
  </action>
  <verify>grep -c "MEMORY_INSTRUMENTATION_ENABLED" examples/lxmf_tdeck/platformio.ini should return 2 (one per env)</verify>
  <done>Both tdeck environments have the build flag defined</done>
</task>

<task type="auto">
  <name>Task 2: Initialize MemoryMonitor in main.cpp</name>
  <files>examples/lxmf_tdeck/src/main.cpp</files>
  <action>
Integrate memory monitoring into the application startup:

1. Add include at top of file (with other includes around line 50-60):
```cpp
// Memory instrumentation
#ifdef MEMORY_INSTRUMENTATION_ENABLED
#include <Instrumentation/MemoryMonitor.h>
#endif
```

2. In setup() function, after LVGL task starts (around line 494-500, after "LVGL task started on core 1" log), add:
```cpp
    // Initialize memory monitoring (if enabled)
#ifdef MEMORY_INSTRUMENTATION_ENABLED
    INFO("Initializing memory monitor...");
    if (RNS::Instrumentation::MemoryMonitor::init(30000)) {
        INFO("Memory monitor started (30s interval)");

        // Register LVGL task for stack monitoring
        TaskHandle_t lvgl_task = UI::LVGL::LVGLInit::get_task_handle();
        if (lvgl_task != nullptr) {
            RNS::Instrumentation::MemoryMonitor::registerTask(lvgl_task, "lvgl");
            INFO("  Registered LVGL task");
        }
    } else {
        WARNING("Failed to start memory monitor");
    }
#endif
```

3. Note: The LVGLInit class needs a getter for the task handle. If get_task_handle() doesn't exist, add it to LVGLInit.h:
   - Check if static TaskHandle_t _task_handle is accessible
   - If not public, add: `static TaskHandle_t get_task_handle() { return _task_handle; }`

The initialization should happen AFTER the LVGL task is created but BEFORE Reticulum initialization (which takes longer and could obscure early memory issues).

Use 30000ms (30 seconds) interval as specified in CONTEXT.md decisions.
  </action>
  <verify>grep -c "MemoryMonitor::init" examples/lxmf_tdeck/src/main.cpp should return 1</verify>
  <done>Memory monitor initializes at boot and LVGL task is registered</done>
</task>

<task type="auto">
  <name>Task 3: Expose LVGL task handle (if needed)</name>
  <files>src/UI/LVGL/LVGLInit.h</files>
  <action>
Check if LVGLInit has a public getter for _task_handle.

Looking at LVGLInit.h, the _task_handle is declared as:
```cpp
static TaskHandle_t _task_handle;
```

If there is no public getter, add one:
```cpp
static TaskHandle_t get_task_handle() { return _task_handle; }
```

Add this in the public section of the class, near other getters like get_display(), get_keyboard(), etc.

If the getter already exists (check first), skip this modification.
  </action>
  <verify>grep -c "get_task_handle" src/UI/LVGL/LVGLInit.h should return at least 1</verify>
  <done>LVGL task handle is accessible for registration with memory monitor</done>
</task>

</tasks>

<verification>
1. Build flag present in both tdeck and tdeck-bluedroid environments
2. main.cpp includes MemoryMonitor.h conditionally
3. MemoryMonitor::init() called in setup() after LVGL task starts
4. LVGL task registered with memory monitor
5. Code compiles with flag enabled: `pio run -e tdeck` (from examples/lxmf_tdeck/)
6. Code compiles with flag disabled (comment out flag, rebuild)
</verification>

<success_criteria>
- Firmware compiles successfully with MEMORY_INSTRUMENTATION_ENABLED
- Firmware compiles successfully without MEMORY_INSTRUMENTATION_ENABLED (no errors from missing code)
- On boot with flag enabled, serial output shows:
  - "Memory monitor started (30s interval)"
  - "Registered LVGL task"
  - Every 30s: "HEAP: int_free=..." and "STACK: lvgl=..."
</success_criteria>

<output>
After completion, create `.planning/phases/01-memory-instrumentation/01-02-SUMMARY.md`
</output>
