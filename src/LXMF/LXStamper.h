#pragma once

#include "../Bytes.h"

#include <atomic>
#include <functional>
#include <tuple>
#include <utility>

namespace LXMF {

	/**
	 * @brief LXMF Stamp Proof-of-Work generator and validator
	 *
	 * Implements hashcash-style proof-of-work stamps for anti-spam protection.
	 * Stamps require finding a 32-byte nonce where SHA256(workblock + stamp)
	 * has a target number of leading zero bits.
	 *
	 * The workblock is generated by expanding the message ID using HKDF,
	 * creating a large memory-hard challenge that makes stamp generation
	 * computationally expensive.
	 */
	class LXStamper {

	public:
		// Stamp size in bytes (256-bit hash)
		static const uint8_t STAMP_SIZE = 32;

		// Workblock expansion rounds
		static const uint16_t WORKBLOCK_EXPAND_ROUNDS = 3000;     // Direct messages (768KB)
		static const uint16_t WORKBLOCK_EXPAND_ROUNDS_PN = 1000;  // Propagation nodes (256KB)

		// Callback for progress updates during stamp generation
		using ProgressCallback = std::function<void(uint32_t rounds)>;

	public:
		/**
		 * @brief Generate a workblock from message ID
		 *
		 * Creates a large memory-hard block by expanding the material
		 * through repeated HKDF operations.
		 *
		 * @param material Message ID or transient ID (32 bytes)
		 * @param expand_rounds Number of HKDF expansion rounds (default 3000)
		 * @return Workblock bytes (256 * expand_rounds bytes)
		 */
		static RNS::Bytes stamp_workblock(
			const RNS::Bytes& material,
			uint16_t expand_rounds = WORKBLOCK_EXPAND_ROUNDS);

		/**
		 * @brief Calculate stamp value (number of leading zero bits)
		 *
		 * @param workblock The workblock generated from message ID
		 * @param stamp The stamp to evaluate
		 * @return Number of leading zero bits in SHA256(workblock + stamp)
		 */
		static uint8_t stamp_value(
			const RNS::Bytes& workblock,
			const RNS::Bytes& stamp);

		/**
		 * @brief Check if a stamp meets the target cost
		 *
		 * @param stamp The stamp to validate
		 * @param target_cost Required number of leading zero bits
		 * @param workblock The workblock generated from message ID
		 * @return true if stamp is valid (has >= target_cost leading zeros)
		 */
		static bool stamp_valid(
			const RNS::Bytes& stamp,
			uint8_t target_cost,
			const RNS::Bytes& workblock);

		/**
		 * @brief Generate a valid stamp (blocking, CPU-intensive)
		 *
		 * Mines for a stamp by repeatedly trying random values until
		 * one is found that meets the target cost requirement.
		 *
		 * @param message_id The message ID to generate stamp for
		 * @param stamp_cost Required number of leading zero bits
		 * @param expand_rounds HKDF expansion rounds (default 3000)
		 * @param cancel Atomic flag to cancel generation (optional)
		 * @param progress Callback for progress updates (optional)
		 * @return Pair of [stamp, value] or empty stamp if cancelled
		 */
		static std::pair<RNS::Bytes, uint8_t> generate_stamp(
			const RNS::Bytes& message_id,
			uint8_t stamp_cost,
			uint16_t expand_rounds = WORKBLOCK_EXPAND_ROUNDS,
			std::atomic<bool>* cancel = nullptr,
			ProgressCallback progress = nullptr);

		/**
		 * @brief Validate a propagation node stamp
		 *
		 * Extracts and validates a stamp from propagation node transient data.
		 * The stamp is the last STAMP_SIZE bytes of transient_data.
		 *
		 * @param transient_data Full data including stamp at end
		 * @param target_cost Required stamp cost
		 * @return Tuple of [transient_id, lxm_data, value, stamp] or all empty on failure
		 */
		static std::tuple<RNS::Bytes, RNS::Bytes, uint8_t, RNS::Bytes>
		validate_pn_stamp(
			const RNS::Bytes& transient_data,
			uint8_t target_cost);

		/**
		 * @brief Pack uint16 as msgpack for salt generation
		 *
		 * Public for testing purposes.
		 *
		 * @param n Number to pack
		 * @return Msgpack-encoded bytes
		 */
		static RNS::Bytes msgpack_pack_uint16(uint16_t n);
	};

}  // namespace LXMF
