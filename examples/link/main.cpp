/*
##########################################################
# This RNS example demonstrates how to set up a link to  #
# a destination, and pass data back and forth over it.   #
##########################################################
*/

#include <UDPInterface.h>
#include <UniversalFileSystem.h>

#include <Reticulum.h>
#include <Interface.h>
#include <Link.h>
#include <Identity.h>
#include <Destination.h>
#include <Packet.h>
#include <Resource.h>
#include <SegmentAccumulator.h>
#include <Transport.h>
#include <Log.h>
#include <Bytes.h>
#include <Type.h>
#include <Utilities/OS.h>

#ifdef ARDUINO
#include <Arduino.h>
#include <SPIFFS.h>
#else
#include <termios.h>
#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#endif

#include <stdlib.h>
#include <unistd.h>
#include <string>
#include <vector>
#include <map>
#include <functional>
#include <fstream>
#include <iostream>

#include <Cryptography/AES.h>
#include <Cryptography/Hashes.h>

// Generate deterministic random data using SHA256 hash chain
// Matches Python resource_server.py algorithm for byte-perfect verification
RNS::Bytes generate_deterministic_random(size_t size) {
	std::string seed_str = "MICRORETICULUM_SEGMENT_TEST_SEED_";
	RNS::Bytes seed((const uint8_t*)seed_str.data(), seed_str.size());
	RNS::Bytes current = RNS::Cryptography::sha256(seed);

	RNS::Bytes data;
	data.reserve(size);

	while (data.size() < size) {
		size_t to_append = std::min((size_t)32, size - data.size());
		data.append(current.left(to_append));
		current = RNS::Cryptography::sha256(current);
	}

	return data;
}

// AES-256-CBC test function
bool test_aes_256_cbc() {
    std::cout << "\n=== AES-256-CBC Test ===" << std::endl;

    // Load test vectors from files (generated by OpenSSL)
    auto readFile = [](const char* path) -> RNS::Bytes {
        std::ifstream file(path, std::ios::binary | std::ios::ate);
        if (!file) {
            std::cerr << "Cannot open: " << path << std::endl;
            return RNS::Bytes::NONE;
        }
        auto size = file.tellg();
        file.seekg(0, std::ios::beg);
        std::vector<uint8_t> buf(size);
        file.read(reinterpret_cast<char*>(buf.data()), size);
        return RNS::Bytes(buf.data(), buf.size());
    };

    RNS::Bytes key = readFile("/tmp/aes_test_key.bin");
    RNS::Bytes iv = readFile("/tmp/aes_test_iv.bin");
    RNS::Bytes ciphertext = readFile("/tmp/aes_ciphertext.bin");
    RNS::Bytes expected = readFile("/tmp/aes_plaintext.bin");

    if (!key || !iv || !ciphertext || !expected) {
        std::cerr << "Failed to load test vectors" << std::endl;
        return false;
    }

    std::cout << "Key size: " << key.size() << ", IV size: " << iv.size() << std::endl;
    std::cout << "Ciphertext size: " << ciphertext.size() << ", Expected size: " << expected.size() << std::endl;
    std::cout << "Key: " << key.toHex() << std::endl;
    std::cout << "IV: " << iv.toHex() << std::endl;
    std::cout << "Ciphertext (first 64): " << ciphertext.left(64).toHex() << std::endl;

    // Decrypt
    RNS::Bytes decrypted = RNS::Cryptography::AES_256_CBC::decrypt(ciphertext, key, iv);

    std::cout << "Decrypted size: " << decrypted.size() << std::endl;
    std::cout << "Decrypted (first 64): " << decrypted.left(64).toHex() << std::endl;
    std::cout << "Expected (first 64): " << expected.left(64).toHex() << std::endl;

    // Compare block by block
    int num_blocks = decrypted.size() / 16;
    int first_diff = -1;
    for (int i = 0; i < num_blocks; i++) {
        RNS::Bytes dec_block = decrypted.mid(i * 16, 16);
        RNS::Bytes exp_block = expected.mid(i * 16, 16);
        bool match = (dec_block == exp_block);
        if (!match && first_diff < 0) first_diff = i;
        std::cout << "Block " << i << ": " << (match ? "OK" : "DIFFER")
                  << " dec=" << dec_block.toHex()
                  << (match ? "" : " exp=" + exp_block.toHex()) << std::endl;
    }

    if (decrypted == expected) {
        std::cout << "*** AES-256-CBC TEST PASSED ***" << std::endl;
        return true;
    } else {
        std::cout << "*** AES-256-CBC TEST FAILED ***" << std::endl;
        return false;
    }
}

// Let's define an app name. We'll use this for all
// destinations we create. Since this echo example
// is part of a range of example utilities, we'll put
// them all within the app namespace "example_utilities"
#define APP_NAME "microreticulum_interop"

RNS::Reticulum reticulum;


/*
##########################################################
#### Server Part #########################################
##########################################################
*/

// A reference to the latest client link that connected
RNS::Link latest_client_link({RNS::Type::NONE});

void client_disconnected(RNS::Link& link) {
	RNS::log("Client disconnected");
}

void server_packet_received(const RNS::Bytes& message, const RNS::Packet& packet) {

	// When data is received over any active link,
	// it will all be directed to the last client
	// that connected.
	std::string text = message.toString();
	RNS::log("Received data on the link: "+text);

	std::string reply_text = "I received \""+text+"\" over the link";
	RNS::Bytes reply_data(reply_text);
	// CBA TODO: Add Packet constructor that accepts Link but doesn't require Destination
	//RNS::Packet(RNS::Type::NONE, latest_client_link, reply_data).send();
	RNS::Packet(latest_client_link, reply_data).send();
}

// When a client establishes a link to our server
// destination, this function will be called with
// a reference to the link.
void client_connected(RNS::Link& link) {
	RNS::log("Client connected");
	link.set_link_closed_callback(client_disconnected);
	link.set_packet_callback(server_packet_received);
	latest_client_link = link;
}

void server_loop(RNS::Destination& destination) {
	// Let the user know that everything is ready
	RNS::log(
		"Link example <"+
		destination.hash().toHex()+
		"> running, waiting for a connection."
	);

	RNS::log("Hit enter to manually send an announce (Ctrl-C to quit)");

	// We enter a loop that runs until the users exits.
	// If the user hits enter, we will announce our server
	// destination on the network, which will let clients
	// know how to create messages directed towards it.
	while (true) {
		reticulum.loop();
		// Non-blocking input
		char ch;
		while (read(STDIN_FILENO, &ch, 1) > 0) {
			if (ch == '\n') {
				destination.announce();
				RNS::log("Sent announce from "+destination.hash().toHex());
			}
		}
	}
}

// This initialisation is executed when the users chooses
// to run as a server
void server() {

	// Randomly create a new identity for our link example
	RNS::Identity server_identity = RNS::Identity();

	// We create a destination that clients can connect to. We
	// want clients to create links to this destination, so we
	// need to create a "single" destination type.
	RNS::Destination server_destination = RNS::Destination(
		server_identity,
		RNS::Type::Destination::IN,
		RNS::Type::Destination::SINGLE,
		APP_NAME,
		"link_server"
	);

	// We configure a function that will get called every time
	// a new client creates a link to this destination.
	server_destination.set_link_established_callback(client_connected);

	// Everything's ready!
	// Let's Wait for client requests or user input
	server_loop(server_destination);
}


/*
##########################################################
#### Client Part #########################################
##########################################################
*/

// Forward declarations for resource callbacks
void resource_started(const RNS::Resource& resource);
void resource_concluded(const RNS::Resource& resource);
void send_test_resource(size_t size = 1024, bool use_random = false);  // Forward declaration
void accumulated_resource_received(const RNS::Bytes& data, const RNS::Bytes& original_hash);

// A reference to the server link
RNS::Link server_link({RNS::Type::NONE});

// Auto-send size (set via command line arg 2, 0 = disabled/interactive)
size_t auto_send_size = 0;

// This function is called when a link
// has been established with the server
void link_established(RNS::Link& link) {
    // We store a reference to the link
    // instance for later use
    server_link = link;

    // Set up segment accumulator for multi-segment resources
    link.setup_segment_accumulator(accumulated_resource_received);

    // Set up resource callbacks to receive resources from server
    link.set_resource_started_callback(resource_started);
    link.set_resource_concluded_callback(resource_concluded);

    // Inform the user that the server is
    // connected
    RNS::log("Link established with server");
    RNS::log("  Segment accumulator configured for multi-segment resources");

    // If auto_send_size is set, send resource automatically
    if (auto_send_size > 0) {
        RNS::log("Auto-sending " + std::to_string(auto_send_size) + " byte resource...");
        send_test_resource(auto_send_size, false);
    } else {
        RNS::log("Commands:");
        RNS::log("  send          - Send a 1KB test resource (pattern data)");
        RNS::log("  send N        - Send an N-byte resource (e.g., 'send 2097152' for 2MB)");
        RNS::log("  send random N - Send N-byte deterministic random data (non-compressible)");
        RNS::log("  quit          - Exit the program");
        RNS::log("  <text>        - Send text as a packet");
        RNS::log("Resource transfers will be automatically received.");
        RNS::log("Multi-segment resources (>1MB) will be accumulated and shown when complete.");
    }
}

// When a link is closed, we'll inform the
// user, and exit the program
void link_closed(RNS::Link& link) {
	if (link.teardown_reason() == RNS::Type::Link::TIMEOUT) {
		RNS::log("The link timed out, exiting now");
	}
	else if (link.teardown_reason() == RNS::Type::Link::DESTINATION_CLOSED) {
		RNS::log("The link was closed by the server, exiting now");
	}
	else {
		RNS::log("Link closed, exiting now");
	}

	//RNS::Reticulum::exit_handler();
	//RNS::Utilities::OS::sleep(1.5);
	_exit(0);
}

// When a packet is received over the link, we
// simply print out the data.
void client_packet_received(const RNS::Bytes& message, const RNS::Packet& packet) {
	std::string text = message.toString();
    RNS::log("Received data on the link: "+text);
    printf("> ");
	fflush(stdout);
}

// Verify received data - checks both pattern and random data formats
bool verify_received_data(const RNS::Bytes& data) {
	// First, check if it matches pattern data
	std::string pattern = "HELLO_RETICULUM_RESOURCE_TEST_DATA_";
	bool is_pattern = true;
	for (size_t i = 0; i < std::min(data.size(), (size_t)100); i++) {
		if (data.data()[i] != (uint8_t)pattern[i % pattern.length()]) {
			is_pattern = false;
			break;
		}
	}

	if (is_pattern) {
		// Verify full pattern data
		for (size_t i = 0; i < data.size(); i++) {
			if (data.data()[i] != (uint8_t)pattern[i % pattern.length()]) {
				RNS::log("  Pattern data mismatch at byte " + std::to_string(i), RNS::LOG_ERROR);
				return false;
			}
		}
		RNS::log("  Pattern data VERIFIED OK (all " + std::to_string(data.size()) + " bytes)");
		return true;
	}

	// Check if it matches deterministic random data
	RNS::Bytes expected_random = generate_deterministic_random(data.size());
	if (data == expected_random) {
		RNS::log("  Random data VERIFIED OK (byte-perfect match, " + std::to_string(data.size()) + " bytes)");
		return true;
	}

	// Find first mismatch for debugging
	for (size_t i = 0; i < data.size(); i++) {
		if (data.data()[i] != expected_random.data()[i]) {
			RNS::log("  Random data mismatch at byte " + std::to_string(i) +
			         " (got 0x" + std::to_string(data.data()[i]) +
			         ", expected 0x" + std::to_string(expected_random.data()[i]) + ")", RNS::LOG_ERROR);
			return false;
		}
	}

	return false;
}

// Segment accumulator callback for complete multi-segment resources
void accumulated_resource_received(const RNS::Bytes& data, const RNS::Bytes& original_hash) {
	RNS::log("=== ACCUMULATED RESOURCE RECEIVED ===");
	RNS::log("  Total size: " + std::to_string(data.size()) + " bytes");
	RNS::log("  Original hash: " + original_hash.toHex().substr(0, 16) + "...");

	// Check if data looks like text or binary
	bool is_text = true;
	for (size_t i = 0; i < std::min(data.size(), (size_t)100); i++) {
		uint8_t c = data.data()[i];
		if (c < 32 || c > 126) {
			is_text = false;
			break;
		}
	}

	if (is_text) {
		RNS::log("  Data (first 100 bytes): " + data.left(100).toString());
	} else {
		RNS::log("  Data (first 32 bytes hex): " + data.left(32).toHex());
	}

	verify_received_data(data);
	RNS::log("=====================================");
}

// Resource callbacks
void resource_started(const RNS::Resource& resource) {
	RNS::log("Resource transfer started from server");
	RNS::log("  Resource size: " + std::to_string(resource.size()) + " bytes");
	RNS::log("  Segment: " + std::to_string(resource.segment_index()) + "/" + std::to_string(resource.total_segments()));
}

void resource_concluded(const RNS::Resource& resource) {
	if (resource.status() == RNS::Type::Resource::COMPLETE) {
		RNS::log("Resource/segment transfer completed!");
		RNS::log("  Received " + std::to_string(resource.size()) + " bytes");
		RNS::log("  Segment: " + std::to_string(resource.segment_index()) + "/" + std::to_string(resource.total_segments()));

		// Check if this is a multi-segment resource
		if (resource.is_segmented()) {
			RNS::log("  Multi-segment resource - routing through accumulator...");
			// Route through segment accumulator
			bool handled = server_link.segment_accumulator().segment_completed(resource);
			if (handled) {
				RNS::log("  Segment accumulated, waiting for more...");
			}
		} else {
			// Single-segment resource - verify and show data
			RNS::log("  Single-segment resource");
			RNS::Bytes data = resource.data();
			verify_received_data(data);
		}
	} else if (resource.status() == RNS::Type::Resource::FAILED) {
		RNS::log("Resource transfer FAILED", RNS::LOG_ERROR);
	} else {
		RNS::log("Resource transfer concluded with status: " + std::to_string(resource.status()));
	}
}

// Callback for when our outgoing resource completes
void send_resource_concluded(const RNS::Resource& resource) {
	if (resource.status() == RNS::Type::Resource::COMPLETE) {
		RNS::log("=== OUTGOING RESOURCE TRANSFER COMPLETE ===");
		RNS::log("  Sent " + std::to_string(resource.size()) + " bytes");
		if (resource.is_segmented()) {
			RNS::log("  All " + std::to_string(resource.total_segments()) + " segments sent successfully!");
		}
		RNS::log("==========================================");
	} else if (resource.status() == RNS::Type::Resource::FAILED) {
		RNS::log("OUTGOING resource transfer FAILED", RNS::LOG_ERROR);
	} else {
		RNS::log("OUTGOING resource transfer concluded with status: " + std::to_string(resource.status()));
	}
}

// Progress callback for resource transfers
void resource_progress_callback(const RNS::Resource& resource) {
	float progress = resource.get_progress() * 100.0f;
	static float last_reported = -10.0f;
	// Report every 5% or at completion
	if (progress - last_reported >= 5.0f || progress >= 99.9f) {
		RNS::log("  Progress: " + std::to_string((int)progress) + "%");
		last_reported = progress;
	}
}

// Send a test resource over the link
// If use_random is true, uses deterministic random data (non-compressible)
// If use_random is false, uses repeating pattern data (highly compressible)
void send_test_resource(size_t size, bool use_random) {
	if (!server_link) {
		RNS::log("Cannot send resource - no active link", RNS::LOG_ERROR);
		return;
	}

	RNS::Bytes test_data;

	if (use_random) {
		// Generate deterministic random data (matches Python's SHA256 hash chain)
		RNS::log("Generating deterministic random data of size " + std::to_string(size) + "...");
		test_data = generate_deterministic_random(size);
		RNS::log("  Random data generated (first 32 bytes hex): " + test_data.left(32).toHex());
	} else {
		// Generate repeating pattern data
		RNS::log("Generating pattern data of size " + std::to_string(size) + "...");
		std::string pattern = "HELLO_RETICULUM_RESOURCE_TEST_DATA_";
		std::vector<uint8_t> buffer(size);
		for (size_t i = 0; i < size; i++) {
			buffer[i] = (uint8_t)pattern[i % pattern.length()];
		}
		test_data = RNS::Bytes(buffer.data(), size);
		RNS::log("  Pattern data generated");
	}

	// Check if this will be segmented
	size_t max_efficient = RNS::Type::Resource::MAX_EFFICIENT_SIZE;
	if (size > max_efficient) {
		int segments = (size + max_efficient - 1) / max_efficient;
		RNS::log("Resource will be split into " + std::to_string(segments) + " segments");
	}

	RNS::log("Creating and sending resource with " + std::to_string(size) + " bytes...");
	if (!use_random) {
		RNS::log("  Data (first 50 bytes): " + test_data.left(50).toString());
	}

	// Create and advertise resource - it will be sent automatically
	// For segmented resources, this creates and sends segment 1
	RNS::Resource resource(test_data, server_link, true, true, send_resource_concluded, resource_progress_callback);
	RNS::log("  Resource hash: " + resource.hash().toHex());
	if (resource.is_segmented()) {
		RNS::log("  Segment 1/" + std::to_string(resource.total_segments()) + " advertised");
	} else {
		RNS::log("  Resource advertised, waiting for receiver request...");
	}
}

void client_loop() {
	// Wait for the link to become active
    RNS::log("Waiting for link to become active...");
    while (!server_link) {
		reticulum.loop();
		RNS::Utilities::OS::sleep(0.01);
	}

	std::string text;
	printf("> ");
	fflush(STDIN_FILENO);
	bool should_quit = false;
    while (!should_quit) {
		reticulum.loop();

		// Non-blocking input
		char ch;
		while (read(STDIN_FILENO, &ch, 1) > 0) {
			if (ch == '\n') {

				// Check if we should quit the example
				if (text == "quit" || text == "q" || text == "exit") {
					should_quit = true;
					server_link.teardown();
				}
				// Send a test resource
				else if (text == "send" || text == "resource") {
					send_test_resource(1024, false);
				}
				// Send deterministic random data: "send random N"
				else if (text.substr(0, 12) == "send random ") {
					size_t size = std::stoul(text.substr(12));
					send_test_resource(size, true);
				}
				// Send pattern data: "send N"
				else if (text.substr(0, 5) == "send ") {
					size_t size = std::stoul(text.substr(5));
					send_test_resource(size, false);
				}
				// If not, send the entered text over the link
				else if (text != "") {
					RNS::Bytes data(text);
					if (data.size() <= RNS::Type::Link::MDU) {
printf("(sending data: %s)\n", text.c_str());
						// CBA TODO: Add Packet constructor that accepts Link but doesn't require Destination
						//RNS::Packet(RNS::Type::NONE, server_link, data).send();
						RNS::Packet(server_link, data).send();
					}
					else {
						RNS::log(
							"Cannot send this packet, the data size of "+
							std::to_string(data.size())+" bytes exceeds the link packet MDU of "+
							std::to_string(RNS::Type::Link::MDU)+" bytes",
							RNS::LOG_ERROR
						);
					}
				}

				text.clear();

				printf("> ");
				fflush(STDIN_FILENO);
			} else {
				text += ch;
			}
		}

		/*
		 * IMPORTANT: Polling frequency affects performance
		 *
		 * microReticulum uses cooperative polling. The application must call
		 * reticulum.loop() frequently. The sleep interval between calls affects:
		 *
		 * - RTT measurement accuracy (shorter = more accurate)
		 * - Resource transfer throughput (shorter = faster)
		 * - Link establishment time (shorter = faster)
		 * - CPU usage (shorter = higher CPU)
		 *
		 * Recommended intervals:
		 * - Native/testing: 10ms (good balance of performance and CPU)
		 * - ESP32 with WiFi: 10-25ms (allow WiFi stack time)
		 * - Battery-powered: Consider interrupt-driven wake with longer sleeps
		 *
		 * Python RNS uses threads with ~25ms sleeps in subsystem loops.
		 */
		RNS::Utilities::OS::sleep(0.01);
	}
}

// This initialisation is executed when the users chooses
// to run as a client
void client(const char* destination_hexhash) {
	// We need a binary representation of the destination
	// hash that was entered on the command line
	RNS::Bytes destination_hash;
	try {
		int dest_len = (RNS::Type::Reticulum::TRUNCATED_HASHLENGTH/8)*2;
		if (strlen(destination_hexhash) != dest_len) {
			throw std::invalid_argument("Destination length is invalid, must be "+std::to_string(dest_len)+" hexadecimal characters ("+std::to_string(dest_len/2)+" bytes).");
		}

		destination_hash.assignHex(destination_hexhash);
	}
	catch (std::exception& e) {
		RNS::log("Invalid destination entered. Check your input!", RNS::LOG_ERROR);
		return;
	}

    // Check if we know a path to the destination
    if (!RNS::Transport::has_path(destination_hash)) {
        RNS::log("Destination is not yet known. Requesting path and waiting for announce to arrive...");
        RNS::Transport::request_path(destination_hash);
        while (!RNS::Transport::has_path(destination_hash)) {
			reticulum.loop();
			RNS::Utilities::OS::sleep(0.01);
		}
	}

    // Recall the server identity
    RNS::Identity server_identity = RNS::Identity::recall(destination_hash);

    // Inform the user that we'll begin connecting
    RNS::log("Establishing link with server...");

    // When the server identity is known, we set
    // up a destination
    RNS::Destination server_destination = RNS::Destination(
        server_identity,
		RNS::Type::Destination::OUT,
		RNS::Type::Destination::SINGLE,
        APP_NAME,
        "link_server"
    );

    // And create a link
    RNS::Link link = RNS::Link(server_destination);

    // We set a callback that will get executed
    // every time a packet is received over the
    // link
    link.set_packet_callback(client_packet_received);

    // We'll also set up functions to inform the
    // user when the link is established or closed
    link.set_link_established_callback(link_established);
    link.set_link_closed_callback(link_closed);

    // Everything is set up, so let's enter a loop
    // for the user to interact with the example
    client_loop();
}


/*
##########################################################
#### Program Startup #####################################
##########################################################
*/

// Signal handler function
void cleanup_handler(int signum) {
	if (signum == SIGINT) {
		printf("\nCtrl+C detected. Performing cleanup...\n");

		printf("Cleanup complete. Exiting.\n");
		_exit(0);
	}
}

// This part of the program runs at startup,
// and parses input of from the user, and then
// starts up the desired program mode.
int main(int argc, char *argv[]) {

#if defined(MEM_LOG)
	RNS::loglevel(RNS::LOG_MEM);
#else
	// Use DEBUG to see resource handling
	RNS::loglevel(RNS::LOG_DEBUG);
	//RNS::loglevel(RNS::LOG_NOTICE);
	//RNS::loglevel(RNS::LOG_TRACE);
#endif

	// Register the signal handler for SIGINT
    signal(SIGINT, cleanup_handler);

	// Setup non-blocking input
	int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
	fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

	// Initialize and register filesystem
	RNS::FileSystem universal_filesystem = new UniversalFileSystem();
	universal_filesystem.init();
	RNS::Utilities::OS::register_filesystem(universal_filesystem);

	// Initialize and register interface
	UDPInterface* udp_iface = new UDPInterface();
	// For interop testing with Python: C++ listens on 4242, sends to 4243
	// Python listens on 4243, sends to 4242
	udp_iface->set_remote_port(4243);
	RNS::Interface udp_interface = udp_iface;
	udp_interface.mode(RNS::Type::Interface::MODE_GATEWAY);
	RNS::Transport::register_interface(udp_interface);
	udp_interface.start();

	// Initialize and start Reticulum
	reticulum.start();

	if (argc <= 1) {
		printf("\nMust specify a destination for client mode, or \"-s\" or \"--server\" for server mode.\n\n");
		printf("Use \"--test-aes\" to run AES-256-CBC test.\n\n");
		return -1;
	}
	// AES test mode
	if (strcmp(argv[1], "--test-aes") == 0) {
		bool result = test_aes_256_cbc();
		return result ? 0 : 1;
	}
	if (strcmp(argv[1], "--server") == 0 || strcmp(argv[1], "-s") == 0) {
		server();
	}
	else {
		// Check for optional second arg for auto-send size (e.g., "./program <hash> 1048576")
		if (argc >= 3) {
			auto_send_size = std::stoul(argv[2]);
			RNS::log("Auto-send mode: will send " + std::to_string(auto_send_size) + " bytes after link established");
		}
		client(argv[1]);
	}

	printf("\nLoop exited. Performing cleanup...\n");

	printf("Cleanup complete. Exiting.\n");

	return 0;
}
