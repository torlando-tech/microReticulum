/*
##########################################################
# This RNS example demonstrates how to set up a link to  #
# a destination, and pass data back and forth over it.   #
##########################################################
*/

#include <UDPInterface.h>
#include <TCPClientInterface.h>
#include <AutoInterface.h>
#ifdef ARDUINO
#include "../common/tcp_interface/tcp_config.h"
#endif
#include <UniversalFileSystem.h>

#include <Reticulum.h>
#include <Interface.h>
#include <Link.h>
#include <Identity.h>
#include <Destination.h>
#include <Packet.h>
#include <Resource.h>
#include <SegmentAccumulator.h>
#include <Transport.h>
#include <Log.h>
#include <Bytes.h>
#include <Type.h>
#include <Utilities/OS.h>

#ifdef ARDUINO
#include <Arduino.h>
#include <SPIFFS.h>
#else
#include <termios.h>
#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#endif

#include <stdlib.h>
#include <unistd.h>
#include <string>
#include <vector>
#include <map>
#include <functional>
#include <fstream>
#include <iostream>

#include <Cryptography/AES.h>
#include <Cryptography/Hashes.h>
#include <MessageBase.h>
#include <ChannelData.h>
#include <Channel.h>
#include <Buffer.h>
#include <MsgPack.h>

#ifdef HAS_DISPLAY
#include <Display.h>
#endif

// Test message class for Channel interoperability testing
class MessageTest : public RNS::MessageBase {
public:
    static constexpr uint16_t MSGTYPE = 0xABCD;

    std::string id;
    std::string data;
    std::string not_serialized;  // Not sent over wire

    MessageTest() {
        // Generate a simple unique ID (not a real UUID, but sufficient for testing)
        not_serialized = "local_" + std::to_string(rand());
    }

    uint16_t msgtype() const override { return MSGTYPE; }

    RNS::Bytes pack() const override {
        // Pack as msgpack array: [id, data]
        MsgPack::Packer packer;
        packer.packArraySize(2);
        packer.pack(id.c_str());
        packer.pack(data.c_str());

        // Convert MsgPack buffer to RNS::Bytes
        const auto& buffer = packer.packet();
        return RNS::Bytes(buffer.data(), buffer.size());
    }

    void unpack(const RNS::Bytes& raw) override {
        // Unpack msgpack array: [id, data]
        MsgPack::Unpacker unpacker;
        unpacker.feed(raw.data(), raw.size());

        size_t arr_size = unpacker.unpackArraySize();
        if (arr_size >= 2) {
            auto unpacked_id = unpacker.unpackString();
            auto unpacked_data = unpacker.unpackString();
            id = std::string(unpacked_id.c_str());
            data = std::string(unpacked_data.c_str());
        }
    }
};

// Generate deterministic random data using SHA256 hash chain
// Matches Python resource_server.py algorithm for byte-perfect verification
RNS::Bytes generate_deterministic_random(size_t size) {
	std::string seed_str = "MICRORETICULUM_SEGMENT_TEST_SEED_";
	RNS::Bytes seed((const uint8_t*)seed_str.data(), seed_str.size());
	RNS::Bytes current = RNS::Cryptography::sha256(seed);

	RNS::Bytes data;
	data.reserve(size);

	while (data.size() < size) {
		size_t to_append = std::min((size_t)32, size - data.size());
		data.append(current.left(to_append));
		current = RNS::Cryptography::sha256(current);
	}

	return data;
}

// AES-256-CBC test function
bool test_aes_256_cbc() {
    std::cout << "\n=== AES-256-CBC Test ===" << std::endl;

    // Load test vectors from files (generated by OpenSSL)
    auto readFile = [](const char* path) -> RNS::Bytes {
        std::ifstream file(path, std::ios::binary | std::ios::ate);
        if (!file) {
            std::cerr << "Cannot open: " << path << std::endl;
            return RNS::Bytes::NONE;
        }
        auto size = file.tellg();
        file.seekg(0, std::ios::beg);
        std::vector<uint8_t> buf(size);
        file.read(reinterpret_cast<char*>(buf.data()), size);
        return RNS::Bytes(buf.data(), buf.size());
    };

    RNS::Bytes key = readFile("/tmp/aes_test_key.bin");
    RNS::Bytes iv = readFile("/tmp/aes_test_iv.bin");
    RNS::Bytes ciphertext = readFile("/tmp/aes_ciphertext.bin");
    RNS::Bytes expected = readFile("/tmp/aes_plaintext.bin");

    if (!key || !iv || !ciphertext || !expected) {
        std::cerr << "Failed to load test vectors" << std::endl;
        return false;
    }

    std::cout << "Key size: " << key.size() << ", IV size: " << iv.size() << std::endl;
    std::cout << "Ciphertext size: " << ciphertext.size() << ", Expected size: " << expected.size() << std::endl;
    std::cout << "Key: " << key.toHex() << std::endl;
    std::cout << "IV: " << iv.toHex() << std::endl;
    std::cout << "Ciphertext (first 64): " << ciphertext.left(64).toHex() << std::endl;

    // Decrypt
    RNS::Bytes decrypted = RNS::Cryptography::AES_256_CBC::decrypt(ciphertext, key, iv);

    std::cout << "Decrypted size: " << decrypted.size() << std::endl;
    std::cout << "Decrypted (first 64): " << decrypted.left(64).toHex() << std::endl;
    std::cout << "Expected (first 64): " << expected.left(64).toHex() << std::endl;

    // Compare block by block
    int num_blocks = decrypted.size() / 16;
    int first_diff = -1;
    for (int i = 0; i < num_blocks; i++) {
        RNS::Bytes dec_block = decrypted.mid(i * 16, 16);
        RNS::Bytes exp_block = expected.mid(i * 16, 16);
        bool match = (dec_block == exp_block);
        if (!match && first_diff < 0) first_diff = i;
        std::cout << "Block " << i << ": " << (match ? "OK" : "DIFFER")
                  << " dec=" << dec_block.toHex()
                  << (match ? "" : " exp=" + exp_block.toHex()) << std::endl;
    }

    if (decrypted == expected) {
        std::cout << "*** AES-256-CBC TEST PASSED ***" << std::endl;
        return true;
    } else {
        std::cout << "*** AES-256-CBC TEST FAILED ***" << std::endl;
        return false;
    }
}

// Let's define an app name. We'll use this for all
// destinations we create. Since this echo example
// is part of a range of example utilities, we'll put
// them all within the app namespace "example_utilities"
#define APP_NAME "microreticulum_interop"

RNS::Reticulum reticulum;


/*
##########################################################
#### Server Part #########################################
##########################################################
*/

// A reference to the latest client link that connected
RNS::Link latest_client_link({RNS::Type::NONE});

#ifdef ARDUINO
// Global destination for Arduino (used by setup/loop pattern)
RNS::Destination arduino_server_destination({RNS::Type::NONE});
// Global interface for Arduino (must persist beyond setup())
RNS::Interface arduino_tcp_interface({RNS::Type::NONE});
// Global identity for Arduino (for display)
RNS::Identity arduino_server_identity({RNS::Type::NONE});
#endif

void client_disconnected(RNS::Link& link) {
	RNS::log("Client disconnected");
}

void server_packet_received(const RNS::Bytes& message, const RNS::Packet& packet) {

	// When data is received over any active link,
	// it will all be directed to the last client
	// that connected.
	std::string text = message.toString();
	RNS::log("Received data on the link: "+text);

	std::string reply_text = "I received \""+text+"\" over the link";
	RNS::Bytes reply_data(reply_text);
	// CBA TODO: Add Packet constructor that accepts Link but doesn't require Destination
	//RNS::Packet(RNS::Type::NONE, latest_client_link, reply_data).send();
	RNS::Packet(latest_client_link, reply_data).send();
}

// When a client establishes a link to our server
// destination, this function will be called with
// a reference to the link.
void client_connected(RNS::Link& link) {
	RNS::log("Client connected");
	link.set_link_closed_callback(client_disconnected);
	link.set_packet_callback(server_packet_received);
	latest_client_link = link;
}

void server_loop(RNS::Destination& destination) {
	// Let the user know that everything is ready
	RNS::log(
		"Link example <"+
		destination.hash().toHex()+
		"> running, waiting for a connection."
	);

	RNS::log("Hit enter to manually send an announce (Ctrl-C to quit)");

	// We enter a loop that runs until the users exits.
	// If the user hits enter, we will announce our server
	// destination on the network, which will let clients
	// know how to create messages directed towards it.
	while (true) {
		reticulum.loop();
		// Non-blocking input
		char ch;
		while (read(STDIN_FILENO, &ch, 1) > 0) {
			if (ch == '\n') {
				destination.announce();
				RNS::log("Sent announce from "+destination.hash().toHex());
			}
		}
	}
}

// This initialisation is executed when the users chooses
// to run as a server
void server() {

	// Randomly create a new identity for our link example
	RNS::Identity server_identity = RNS::Identity();

	// We create a destination that clients can connect to. We
	// want clients to create links to this destination, so we
	// need to create a "single" destination type.
	RNS::Destination server_destination = RNS::Destination(
		server_identity,
		RNS::Type::Destination::IN,
		RNS::Type::Destination::SINGLE,
		APP_NAME,
		"link_server"
	);

	// We configure a function that will get called every time
	// a new client creates a link to this destination.
	server_destination.set_link_established_callback(client_connected);

	// Everything's ready!
	// Let's Wait for client requests or user input
	server_loop(server_destination);
}


/*
##########################################################
#### Client Part #########################################
##########################################################
*/

// Forward declarations for resource callbacks
void resource_started(const RNS::Resource& resource);
void resource_concluded(const RNS::Resource& resource);
void send_test_resource(size_t size = 1024, bool use_random = false);  // Forward declaration
void accumulated_resource_received(const RNS::Bytes& data, const RNS::Bytes& original_hash);

// A reference to the server link
RNS::Link server_link({RNS::Type::NONE});
RNS::Resource last_sent_resource({RNS::Type::NONE});  // Track last sent resource for cancel testing

// Auto-send size (set via command line arg 2, 0 = disabled/interactive)
size_t auto_send_size = 0;

// This function is called when a link
// has been established with the server
void link_established(RNS::Link& link) {
    // We store a reference to the link
    // instance for later use
    server_link = link;

    // Set up segment accumulator for multi-segment resources
    link.setup_segment_accumulator(accumulated_resource_received);

    // Set up resource callbacks to receive resources from server
    link.set_resource_started_callback(resource_started);
    link.set_resource_concluded_callback(resource_concluded);

    // Inform the user that the server is
    // connected
    RNS::log("Link established with server");
    RNS::log("  Segment accumulator configured for multi-segment resources");

    // If auto_send_size is set, send resource automatically
    if (auto_send_size > 0) {
        RNS::log("Auto-sending " + std::to_string(auto_send_size) + " byte resource...");
        send_test_resource(auto_send_size, false);
    } else {
        RNS::log("Commands:");
        RNS::log("  send          - Send a 1KB test resource (pattern data)");
        RNS::log("  send N        - Send an N-byte resource (e.g., 'send 2097152' for 2MB)");
        RNS::log("  send random N - Send N-byte deterministic random data (non-compressible)");
        RNS::log("  cancel        - Cancel the last sent resource (sends RESOURCE_ICL)");
        RNS::log("  channel       - Test Channel message passing (basic interop test)");
        RNS::log("  test channel basic    - Automated PING/PONG round-trip test");
        RNS::log("  test channel wire     - Wire format verification test");
        RNS::log("  test channel sequence - Sequence increment test (5 messages)");
        RNS::log("  test channel empty    - Empty payload encoding test");
        RNS::log("Buffer commands:");
        RNS::log("  buffer ping           - Send PING, expect PONG via Buffer");
        RNS::log("  buffer write <text>   - Write text to buffer, echo expected");
        RNS::log("  buffer test small     - Test small (6 byte) round-trip");
        RNS::log("  buffer test big       - Test 32KB round-trip");
        RNS::log("  quit          - Exit the program");
        RNS::log("  <text>        - Send text as a packet");
        RNS::log("Resource transfers will be automatically received.");
        RNS::log("Multi-segment resources (>1MB) will be accumulated and shown when complete.");
    }
}

// When a link is closed, we'll inform the
// user, and exit the program
void link_closed(RNS::Link& link) {
	if (link.teardown_reason() == RNS::Type::Link::TIMEOUT) {
		RNS::log("The link timed out, exiting now");
	}
	else if (link.teardown_reason() == RNS::Type::Link::DESTINATION_CLOSED) {
		RNS::log("The link was closed by the server, exiting now");
	}
	else {
		RNS::log("Link closed, exiting now");
	}

	//RNS::Reticulum::exit_handler();
	//RNS::Utilities::OS::sleep(1.5);
	_exit(0);
}

// When a packet is received over the link, we
// simply print out the data.
void client_packet_received(const RNS::Bytes& message, const RNS::Packet& packet) {
	std::string text = message.toString();
    RNS::log("Received data on the link: "+text);
    printf("> ");
	fflush(stdout);
}

// Verify received data - checks both pattern and random data formats
bool verify_received_data(const RNS::Bytes& data) {
	// First, check if it matches pattern data
	std::string pattern = "HELLO_RETICULUM_RESOURCE_TEST_DATA_";
	bool is_pattern = true;
	for (size_t i = 0; i < std::min(data.size(), (size_t)100); i++) {
		if (data.data()[i] != (uint8_t)pattern[i % pattern.length()]) {
			is_pattern = false;
			break;
		}
	}

	if (is_pattern) {
		// Verify full pattern data
		for (size_t i = 0; i < data.size(); i++) {
			if (data.data()[i] != (uint8_t)pattern[i % pattern.length()]) {
				RNS::log("  Pattern data mismatch at byte " + std::to_string(i), RNS::LOG_ERROR);
				return false;
			}
		}
		RNS::log("  Pattern data VERIFIED OK (all " + std::to_string(data.size()) + " bytes)");
		return true;
	}

	// Check if it matches deterministic random data
	RNS::Bytes expected_random = generate_deterministic_random(data.size());
	if (data == expected_random) {
		RNS::log("  Random data VERIFIED OK (byte-perfect match, " + std::to_string(data.size()) + " bytes)");
		return true;
	}

	// Find first mismatch for debugging
	for (size_t i = 0; i < data.size(); i++) {
		if (data.data()[i] != expected_random.data()[i]) {
			RNS::log("  Random data mismatch at byte " + std::to_string(i) +
			         " (got 0x" + std::to_string(data.data()[i]) +
			         ", expected 0x" + std::to_string(expected_random.data()[i]) + ")", RNS::LOG_ERROR);
			return false;
		}
	}

	return false;
}

// Segment accumulator callback for complete multi-segment resources
void accumulated_resource_received(const RNS::Bytes& data, const RNS::Bytes& original_hash) {
	RNS::log("=== ACCUMULATED RESOURCE RECEIVED ===");
	RNS::log("  Total size: " + std::to_string(data.size()) + " bytes");
	RNS::log("  Original hash: " + original_hash.toHex().substr(0, 16) + "...");

	// Check if data looks like text or binary
	bool is_text = true;
	for (size_t i = 0; i < std::min(data.size(), (size_t)100); i++) {
		uint8_t c = data.data()[i];
		if (c < 32 || c > 126) {
			is_text = false;
			break;
		}
	}

	if (is_text) {
		RNS::log("  Data (first 100 bytes): " + data.left(100).toString());
	} else {
		RNS::log("  Data (first 32 bytes hex): " + data.left(32).toHex());
	}

	verify_received_data(data);
	RNS::log("=====================================");
}

// Resource callbacks
void resource_started(const RNS::Resource& resource) {
	RNS::log("Resource transfer started from server");
	RNS::log("  Resource size: " + std::to_string(resource.size()) + " bytes");
	RNS::log("  Segment: " + std::to_string(resource.segment_index()) + "/" + std::to_string(resource.total_segments()));
}

void resource_concluded(const RNS::Resource& resource) {
	if (resource.status() == RNS::Type::Resource::COMPLETE) {
		RNS::log("Resource/segment transfer completed!");
		RNS::log("  Received " + std::to_string(resource.size()) + " bytes");
		RNS::log("  Segment: " + std::to_string(resource.segment_index()) + "/" + std::to_string(resource.total_segments()));

		// Check if this is a multi-segment resource
		if (resource.is_segmented()) {
			RNS::log("  Multi-segment resource - routing through accumulator...");
			// Route through segment accumulator
			bool handled = server_link.segment_accumulator().segment_completed(resource);
			if (handled) {
				RNS::log("  Segment accumulated, waiting for more...");
			}
		} else {
			// Single-segment resource - verify and show data
			RNS::log("  Single-segment resource");
			RNS::Bytes data = resource.data();
			verify_received_data(data);
		}
	} else if (resource.status() == RNS::Type::Resource::FAILED) {
		RNS::log("Resource transfer FAILED", RNS::LOG_ERROR);
	} else {
		RNS::log("Resource transfer concluded with status: " + std::to_string(resource.status()));
	}
}

// Callback for when our outgoing resource completes
void send_resource_concluded(const RNS::Resource& resource) {
	if (resource.status() == RNS::Type::Resource::COMPLETE) {
		RNS::log("=== OUTGOING RESOURCE TRANSFER COMPLETE ===");
		RNS::log("  Sent " + std::to_string(resource.size()) + " bytes");
		if (resource.is_segmented()) {
			RNS::log("  All " + std::to_string(resource.total_segments()) + " segments sent successfully!");
		}
		RNS::log("==========================================");
	} else if (resource.status() == RNS::Type::Resource::FAILED) {
		RNS::log("OUTGOING resource transfer FAILED", RNS::LOG_ERROR);
	} else {
		RNS::log("OUTGOING resource transfer concluded with status: " + std::to_string(resource.status()));
	}
}

// Progress callback for resource transfers
void resource_progress_callback(const RNS::Resource& resource) {
	float progress = resource.get_progress() * 100.0f;
	static float last_reported = -10.0f;
	// Report every 5% or at completion
	if (progress - last_reported >= 5.0f || progress >= 99.9f) {
		RNS::log("  Progress: " + std::to_string((int)progress) + "%");
		last_reported = progress;
	}
}

// Send a test resource over the link
// If use_random is true, uses deterministic random data (non-compressible)
// If use_random is false, uses repeating pattern data (highly compressible)
void send_test_resource(size_t size, bool use_random) {
	if (!server_link) {
		RNS::log("Cannot send resource - no active link", RNS::LOG_ERROR);
		return;
	}

	RNS::Bytes test_data;

	if (use_random) {
		// Generate deterministic random data (matches Python's SHA256 hash chain)
		RNS::log("Generating deterministic random data of size " + std::to_string(size) + "...");
		test_data = generate_deterministic_random(size);
		RNS::log("  Random data generated (first 32 bytes hex): " + test_data.left(32).toHex());
	} else {
		// Generate repeating pattern data
		RNS::log("Generating pattern data of size " + std::to_string(size) + "...");
		std::string pattern = "HELLO_RETICULUM_RESOURCE_TEST_DATA_";
		std::vector<uint8_t> buffer(size);
		for (size_t i = 0; i < size; i++) {
			buffer[i] = (uint8_t)pattern[i % pattern.length()];
		}
		test_data = RNS::Bytes(buffer.data(), size);
		RNS::log("  Pattern data generated");
	}

	// Check if this will be segmented
	size_t max_efficient = RNS::Type::Resource::MAX_EFFICIENT_SIZE;
	if (size > max_efficient) {
		int segments = (size + max_efficient - 1) / max_efficient;
		RNS::log("Resource will be split into " + std::to_string(segments) + " segments");
	}

	RNS::log("Creating and sending resource with " + std::to_string(size) + " bytes...");
	if (!use_random) {
		RNS::log("  Data (first 50 bytes): " + test_data.left(50).toString());
	}

	// Create and advertise resource - it will be sent automatically
	// For segmented resources, this creates and sends segment 1
	RNS::Resource resource(test_data, server_link, true, true, send_resource_concluded, resource_progress_callback);
	last_sent_resource = resource;  // Store for potential cancel
	RNS::log("  Resource hash: " + resource.hash().toHex());
	if (resource.is_segmented()) {
		RNS::log("  Segment 1/" + std::to_string(resource.total_segments()) + " advertised");
	} else {
		RNS::log("  Resource advertised, waiting for receiver request...");
	}
}

void client_loop() {
	// Wait for the link to become active
    RNS::log("Waiting for link to become active...");
    while (!server_link) {
		reticulum.loop();
		RNS::Utilities::OS::sleep(0.01);
	}

	std::string text;
	printf("> ");
	fflush(STDIN_FILENO);
	bool should_quit = false;
    while (!should_quit) {
		reticulum.loop();

		// Non-blocking input
		char ch;
		while (read(STDIN_FILENO, &ch, 1) > 0) {
			if (ch == '\n') {

				// Check if we should quit the example
				if (text == "quit" || text == "q" || text == "exit") {
					should_quit = true;
					server_link.teardown();
				}
				// Send a test resource
				else if (text == "send" || text == "resource") {
					send_test_resource(1024, false);
				}
				// Send deterministic random data: "send random N"
				else if (text.substr(0, 12) == "send random ") {
					size_t size = std::stoul(text.substr(12));
					send_test_resource(size, true);
				}
				// Send pattern data: "send N"
				else if (text.substr(0, 5) == "send ") {
					size_t size = std::stoul(text.substr(5));
					send_test_resource(size, false);
				}
				// Cancel last sent resource
				else if (text == "cancel") {
					if (!last_sent_resource) {
						RNS::log("No resource to cancel", RNS::LOG_ERROR);
					} else {
						RNS::log("Cancelling resource " + last_sent_resource.hash().toHex());
						last_sent_resource.cancel();
						RNS::log("Cancel sent (RESOURCE_ICL)");
					}
				}
				// Channel test command (legacy - simple test)
				else if (text == "channel") {
					if (!server_link) {
						RNS::log("No link established", RNS::LOG_ERROR);
					}
					else {
						// Get channel
						RNS::Channel channel = server_link.get_channel();

						// Register message type
						channel.register_message_type<MessageTest>();

						// Add handler to receive responses
						channel.add_message_handler([](RNS::MessageBase& msg) -> bool {
							if (msg.msgtype() == MessageTest::MSGTYPE) {
								MessageTest& test_msg = static_cast<MessageTest&>(msg);
								RNS::log("Channel received: id=" + test_msg.id + ", data=" + test_msg.data);
								return true;  // Message handled
							}
							return false;
						});

						// Create and send test message
						MessageTest test_msg;
						test_msg.id = "test_" + std::to_string(rand() % 10000);
						test_msg.data = "Hello";

						RNS::log("Sending channel message: id=" + test_msg.id + ", data=" + test_msg.data);

						channel.send(test_msg);
					}
				}
				// ========== AUTOMATED CHANNEL TESTS ==========
				// Basic round-trip test with structured output
				else if (text == "test channel basic") {
					if (!server_link) {
						printf("[TEST:channel_basic_roundtrip:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:channel_basic_roundtrip:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();
						channel.register_message_type<MessageTest>();

						// Track test state
						static bool test_response_received = false;
						static std::string test_expected_id;
						test_response_received = false;

						channel.add_message_handler([](RNS::MessageBase& msg) -> bool {
							if (msg.msgtype() == MessageTest::MSGTYPE) {
								MessageTest& test_msg = static_cast<MessageTest&>(msg);
								printf("[DATA:rx_id=%s]\n", test_msg.id.c_str());
								printf("[DATA:rx_data=%s]\n", test_msg.data.c_str());
								fflush(stdout);

								// Verify response
								if (test_msg.id == test_expected_id && test_msg.data == "PONG") {
									printf("[TEST:channel_basic_roundtrip:PASS]\n");
								} else {
									printf("[TEST:channel_basic_roundtrip:FAIL:unexpected_response]\n");
								}
								fflush(stdout);
								test_response_received = true;
								return true;
							}
							return false;
						});

						// Send PING message
						MessageTest test_msg;
						test_msg.id = "basic_" + std::to_string(rand() % 10000);
						test_msg.data = "PING";
						test_expected_id = test_msg.id;

						printf("[DATA:tx_id=%s]\n", test_msg.id.c_str());
						printf("[DATA:tx_data=%s]\n", test_msg.data.c_str());
						fflush(stdout);

						// Log wire format of packed message
						RNS::Bytes packed = test_msg.pack();
						printf("[WIRE:TX_PAYLOAD:%s]\n", packed.toHex().c_str());
						fflush(stdout);

						channel.send(test_msg);
					}
				}
				// Wire format verification test
				else if (text == "test channel wire") {
					if (!server_link) {
						printf("[TEST:channel_wire_format:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:channel_wire_format:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();
						channel.register_message_type<MessageTest>();

						channel.add_message_handler([](RNS::MessageBase& msg) -> bool {
							if (msg.msgtype() == MessageTest::MSGTYPE) {
								MessageTest& test_msg = static_cast<MessageTest&>(msg);
								printf("[DATA:rx_id=%s]\n", test_msg.id.c_str());
								printf("[DATA:rx_data=%s]\n", test_msg.data.c_str());

								// Verify we got expected single-char response
								if (test_msg.id == "A" && test_msg.data == "B") {
									printf("[TEST:channel_wire_format:PASS]\n");
								} else {
									printf("[TEST:channel_wire_format:FAIL:unexpected_data]\n");
								}
								fflush(stdout);
								return true;
							}
							return false;
						});

						// Send WIRE_TEST message to trigger server verification
						MessageTest test_msg;
						test_msg.id = "wire_test";
						test_msg.data = "WIRE_TEST";

						// Also verify our own encoding
						RNS::Bytes packed = test_msg.pack();
						printf("[WIRE:TX_PAYLOAD:%s]\n", packed.toHex().c_str());
						fflush(stdout);

						channel.send(test_msg);
					}
				}
				// Sequence test - send multiple messages
				else if (text == "test channel sequence") {
					if (!server_link) {
						printf("[TEST:channel_sequence_increment:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:channel_sequence_increment:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();
						channel.register_message_type<MessageTest>();

						static int seq_responses_received = 0;
						seq_responses_received = 0;

						channel.add_message_handler([](RNS::MessageBase& msg) -> bool {
							if (msg.msgtype() == MessageTest::MSGTYPE) {
								MessageTest& test_msg = static_cast<MessageTest&>(msg);
								printf("[DATA:seq_response_%d=%s]\n", seq_responses_received, test_msg.data.c_str());
								fflush(stdout);
								seq_responses_received++;

								if (seq_responses_received >= 5) {
									printf("[TEST:channel_sequence_increment:PASS]\n");
									fflush(stdout);
								}
								return true;
							}
							return false;
						});

						// Send 5 messages to test sequence incrementing
						for (int i = 0; i < 5; i++) {
							MessageTest test_msg;
							test_msg.id = "seq_" + std::to_string(i);
							test_msg.data = "SEQ_TEST_" + std::to_string(i);
							printf("[DATA:tx_seq_%d=%s]\n", i, test_msg.data.c_str());
							fflush(stdout);
							channel.send(test_msg);
						}
					}
				}
				// Empty payload test
				else if (text == "test channel empty") {
					if (!server_link) {
						printf("[TEST:channel_empty_payload:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:channel_empty_payload:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();
						channel.register_message_type<MessageTest>();

						channel.add_message_handler([](RNS::MessageBase& msg) -> bool {
							if (msg.msgtype() == MessageTest::MSGTYPE) {
								MessageTest& test_msg = static_cast<MessageTest&>(msg);
								printf("[DATA:rx_id_len=%zu]\n", test_msg.id.length());
								printf("[DATA:rx_data_len=%zu]\n", test_msg.data.length());

								// Verify empty response
								if (test_msg.id.empty() && test_msg.data.empty()) {
									printf("[TEST:channel_empty_payload:PASS]\n");
								} else {
									printf("[TEST:channel_empty_payload:FAIL:not_empty]\n");
								}
								fflush(stdout);
								return true;
							}
							return false;
						});

						// Send EMPTY_TEST message
						MessageTest test_msg;
						test_msg.id = "empty_test";
						test_msg.data = "EMPTY_TEST";

						// Verify our empty encoding
						MessageTest empty_msg;
						empty_msg.id = "";
						empty_msg.data = "";
						RNS::Bytes packed = empty_msg.pack();
						printf("[WIRE:EMPTY_PAYLOAD:%s]\n", packed.toHex().c_str());
						// Expected: 92 A0 A0
						if (packed.size() == 3 && packed[0] == 0x92 && packed[1] == 0xA0 && packed[2] == 0xA0) {
							printf("[DATA:empty_encoding=correct]\n");
						} else {
							printf("[DATA:empty_encoding=WRONG]\n");
						}
						fflush(stdout);

						channel.send(test_msg);
					}
				}
				// Run all channel tests
				else if (text == "test channel all") {
					printf("[TEST:channel_all:START]\n");
					fflush(stdout);
					printf("Running all channel tests in sequence...\n");
					printf("Type 'test channel basic' then 'test channel wire' etc.\n");
					fflush(stdout);
				}
				// ========== BUFFER TESTS ==========
				// Simple buffer ping test
				else if (text == "buffer ping") {
					if (!server_link) {
						printf("[TEST:buffer_ping:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:buffer_ping:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();

						// Create bidirectional buffer
						// Both sides use stream_id 0 for simplicity
						auto buffer_pair = RNS::Buffer::create_bidirectional_buffer(
							0, 0, channel,
							[](size_t ready_bytes) {
								printf("[BUFFER:READY:%zu]\n", ready_bytes);
								fflush(stdout);
							}
						);
						auto& reader = buffer_pair.first;
						auto& writer = buffer_pair.second;

						// Send PING
						std::string ping_str = "PING\n";
						RNS::Bytes ping_data((const uint8_t*)ping_str.data(), ping_str.size());
						writer.write(ping_data);
						writer.flush();
						printf("[BUFFER:TX:PING]\n");
						fflush(stdout);

						// Wait for response with timeout (10 seconds)
						RNS::Bytes received;
						int timeout_ms = 10000;
						int elapsed_ms = 0;
						const int poll_interval_ms = 10;

						while (elapsed_ms < timeout_ms) {
							reticulum.loop();

							if (reader.available() > 0) {
								received = reader.read();
								break;
							}

							RNS::Utilities::OS::sleep(poll_interval_ms / 1000.0);
							elapsed_ms += poll_interval_ms;
						}

						// Verify response
						std::string expected_str = "PONG\n";
						RNS::Bytes expected((const uint8_t*)expected_str.data(), expected_str.size());

						if (received.size() == 0) {
							printf("[TEST:buffer_ping:FAIL:timeout_no_response]\n");
						} else if (received == expected) {
							printf("[BUFFER:RX:PONG]\n");
							printf("[TEST:buffer_ping:PASS]\n");
						} else {
							printf("[BUFFER:RX:%s]\n", received.toHex().c_str());
							printf("[TEST:buffer_ping:FAIL:wrong_response_got_%zu_bytes]\n", received.size());
						}
						fflush(stdout);
					}
				}
				// Buffer write command
				else if (text.substr(0, 13) == "buffer write ") {
					if (!server_link) {
						RNS::log("No link established", RNS::LOG_ERROR);
					}
					else {
						std::string payload = text.substr(13) + "\n";
						RNS::Channel channel = server_link.get_channel();

						auto buffer_pair = RNS::Buffer::create_bidirectional_buffer(
							0, 0, channel,
							[](size_t ready_bytes) {
								printf("[BUFFER:READY:%zu]\n", ready_bytes);
								fflush(stdout);
							}
						);
						auto& writer = buffer_pair.second;

						RNS::Bytes data((const uint8_t*)payload.data(), payload.size());
						size_t written = writer.write(data);
						writer.flush();
						printf("[BUFFER:TX:%zu bytes]\n", written);
						fflush(stdout);
					}
				}
				// Small buffer test (6 bytes - "Hello\n")
				else if (text == "buffer test small") {
					if (!server_link) {
						printf("[TEST:buffer_small:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:buffer_small:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();

						auto buffer_pair = RNS::Buffer::create_bidirectional_buffer(
							0, 0, channel,
							[](size_t ready_bytes) {
								printf("[BUFFER:READY:%zu]\n", ready_bytes);
								fflush(stdout);
							}
						);
						auto& reader = buffer_pair.first;
						auto& writer = buffer_pair.second;

						// Send "Hello\n"
						std::string hello_str = "Hello\n";
						RNS::Bytes sent_data((const uint8_t*)hello_str.data(), hello_str.size());
						writer.write(sent_data);
						writer.flush();
						printf("[BUFFER:TX:Hello\\n (6 bytes)]\n");
						fflush(stdout);

						// Wait for response with timeout (15 seconds)
						RNS::Bytes received;
						int timeout_ms = 15000;
						int elapsed_ms = 0;
						const int poll_interval_ms = 10;

						while (elapsed_ms < timeout_ms) {
							reticulum.loop();

							if (reader.available() > 0) {
								received = reader.read();
								break;
							}

							RNS::Utilities::OS::sleep(poll_interval_ms / 1000.0);
							elapsed_ms += poll_interval_ms;
						}

						// Verify response (expect exact echo)
						if (received.size() == 0) {
							printf("[TEST:buffer_small:FAIL:timeout_no_response]\n");
						} else if (received == sent_data) {
							printf("[BUFFER:RX:%zu bytes (byte-perfect match)]\n", received.size());
							printf("[TEST:buffer_small:PASS]\n");
						} else {
							printf("[BUFFER:RX:%zu bytes (expected %zu)]\n", received.size(), sent_data.size());
							printf("[TEST:buffer_small:FAIL:data_mismatch]\n");
						}
						fflush(stdout);
					}
				}
				// Big buffer test (32KB)
				else if (text == "buffer test big") {
					if (!server_link) {
						printf("[TEST:buffer_big:FAIL:no_link]\n");
						fflush(stdout);
					}
					else {
						printf("[TEST:buffer_big:START]\n");
						fflush(stdout);

						RNS::Channel channel = server_link.get_channel();

						auto buffer_pair = RNS::Buffer::create_bidirectional_buffer(
							0, 0, channel,
							[](size_t ready_bytes) {
								printf("[BUFFER:READY:%zu]\n", ready_bytes);
								fflush(stdout);
							}
						);
						auto& reader = buffer_pair.first;
						auto& writer = buffer_pair.second;

						// Generate 32KB of data (repeating digits pattern)
						const size_t TEST_SIZE = 32 * 1024;
						std::vector<uint8_t> test_vec(TEST_SIZE);
						for (size_t i = 0; i < TEST_SIZE; i++) {
							test_vec[i] = (uint8_t)('0' + (i % 10));
						}
						RNS::Bytes sent_data(test_vec.data(), test_vec.size());

						// Write in chunks
						size_t offset = 0;
						while (offset < TEST_SIZE) {
							size_t remaining = TEST_SIZE - offset;
							RNS::Bytes chunk = sent_data.mid(offset, std::min(remaining, (size_t)4096));
							size_t written = writer.write(chunk);
							offset += written;
							// Progress every 8KB
							if (offset % 8192 == 0 || offset == TEST_SIZE) {
								printf("[BUFFER:TX:sent %zu/%zu bytes]\n", offset, TEST_SIZE);
								fflush(stdout);
							}
						}
						writer.flush();
						printf("[BUFFER:TX:complete %zu bytes]\n", TEST_SIZE);
						fflush(stdout);

						// Wait for response with timeout (60 seconds)
						// Accumulate all received data
						RNS::Bytes received;
						int timeout_ms = 60000;
						int elapsed_ms = 0;
						const int poll_interval_ms = 10;
						int last_progress_pct = -1;

						while (elapsed_ms < timeout_ms && received.size() < TEST_SIZE) {
							reticulum.loop();

							if (reader.available() > 0) {
								RNS::Bytes chunk = reader.read();
								received += chunk;

								// Progress reporting every 10%
								int progress_pct = (int)(100 * received.size() / TEST_SIZE);
								if (progress_pct / 10 > last_progress_pct / 10) {
									printf("[BUFFER:RX:received %zu/%zu bytes (%d%%)]\n",
										   received.size(), TEST_SIZE, progress_pct);
									fflush(stdout);
									last_progress_pct = progress_pct;
								}
							}

							RNS::Utilities::OS::sleep(poll_interval_ms / 1000.0);
							elapsed_ms += poll_interval_ms;
						}

						// Verify response (byte-perfect match)
						if (received.size() == 0) {
							printf("[TEST:buffer_big:FAIL:timeout_no_response]\n");
						} else if (received.size() != TEST_SIZE) {
							printf("[BUFFER:RX:%zu bytes (expected %zu)]\n", received.size(), TEST_SIZE);
							printf("[TEST:buffer_big:FAIL:size_mismatch]\n");
						} else if (received == sent_data) {
							printf("[BUFFER:RX:%zu bytes (byte-perfect match)]\n", received.size());
							printf("[TEST:buffer_big:PASS]\n");
						} else {
							// Find first mismatch position for debugging
							size_t mismatch_pos = 0;
							for (size_t i = 0; i < TEST_SIZE; i++) {
								if (received[i] != sent_data[i]) {
									mismatch_pos = i;
									break;
								}
							}
							printf("[BUFFER:RX:%zu bytes - mismatch at position %zu]\n",
								   received.size(), mismatch_pos);
							printf("[TEST:buffer_big:FAIL:data_mismatch_at_%zu]\n", mismatch_pos);
						}
						fflush(stdout);
					}
				}
				// If not, send the entered text over the link
				else if (text != "") {
					RNS::Bytes data(text);
					if (data.size() <= RNS::Type::Link::MDU) {
printf("(sending data: %s)\n", text.c_str());
						// CBA TODO: Add Packet constructor that accepts Link but doesn't require Destination
						//RNS::Packet(RNS::Type::NONE, server_link, data).send();
						RNS::Packet(server_link, data).send();
					}
					else {
						RNS::log(
							"Cannot send this packet, the data size of "+
							std::to_string(data.size())+" bytes exceeds the link packet MDU of "+
							std::to_string(RNS::Type::Link::MDU)+" bytes",
							RNS::LOG_ERROR
						);
					}
				}

				text.clear();

				printf("> ");
				fflush(STDIN_FILENO);
			} else {
				text += ch;
			}
		}

		/*
		 * IMPORTANT: Polling frequency affects performance
		 *
		 * microReticulum uses cooperative polling. The application must call
		 * reticulum.loop() frequently. The sleep interval between calls affects:
		 *
		 * - RTT measurement accuracy (shorter = more accurate)
		 * - Resource transfer throughput (shorter = faster)
		 * - Link establishment time (shorter = faster)
		 * - CPU usage (shorter = higher CPU)
		 *
		 * Recommended intervals:
		 * - Native/testing: 10ms (good balance of performance and CPU)
		 * - ESP32 with WiFi: 10-25ms (allow WiFi stack time)
		 * - Battery-powered: Consider interrupt-driven wake with longer sleeps
		 *
		 * Python RNS uses threads with ~25ms sleeps in subsystem loops.
		 */
		RNS::Utilities::OS::sleep(0.01);
	}
}

// This initialisation is executed when the users chooses
// to run as a client
void client(const char* destination_hexhash) {
	// We need a binary representation of the destination
	// hash that was entered on the command line
	RNS::Bytes destination_hash;
	try {
		int dest_len = (RNS::Type::Reticulum::TRUNCATED_HASHLENGTH/8)*2;
		if (strlen(destination_hexhash) != dest_len) {
			throw std::invalid_argument("Destination length is invalid, must be "+std::to_string(dest_len)+" hexadecimal characters ("+std::to_string(dest_len/2)+" bytes).");
		}

		destination_hash.assignHex(destination_hexhash);
	}
	catch (std::exception& e) {
		RNS::log("Invalid destination entered. Check your input!", RNS::LOG_ERROR);
		return;
	}

    // Check if we know a path to the destination
    if (!RNS::Transport::has_path(destination_hash)) {
        RNS::log("Destination is not yet known. Requesting path and waiting for announce to arrive...");
        RNS::Transport::request_path(destination_hash);
        while (!RNS::Transport::has_path(destination_hash)) {
			reticulum.loop();
			RNS::Utilities::OS::sleep(0.01);
		}
	}

    // Recall the server identity
    RNS::Identity server_identity = RNS::Identity::recall(destination_hash);

    // Inform the user that we'll begin connecting
    RNS::log("Establishing link with server...");

    // When the server identity is known, we set
    // up a destination
    RNS::Destination server_destination = RNS::Destination(
        server_identity,
		RNS::Type::Destination::OUT,
		RNS::Type::Destination::SINGLE,
        APP_NAME,
        "link_server"
    );

    // And create a link
    RNS::Link link = RNS::Link(server_destination);

    // We set a callback that will get executed
    // every time a packet is received over the
    // link
    link.set_packet_callback(client_packet_received);

    // We'll also set up functions to inform the
    // user when the link is established or closed
    link.set_link_established_callback(link_established);
    link.set_link_closed_callback(link_closed);

    // Everything is set up, so let's enter a loop
    // for the user to interact with the example
    client_loop();
}


/*
##########################################################
#### Program Startup #####################################
##########################################################
*/

#ifdef ARDUINO

// Arduino setup function - runs once at boot
void setup() {
	Serial.begin(115200);
	while (!Serial && millis() < 3000); // Wait up to 3s for serial

	RNS::loglevel(RNS::LOG_DEBUG);
	RNS::log("=== microReticulum Link Example for ESP32 ===");

	// Initialize display (before other I2C devices)
	#ifdef HAS_DISPLAY
	if (RNS::Display::init()) {
		RNS::log("Display initialized successfully");
	} else {
		RNS::log("Display initialization failed (continuing without display)");
	}
	#endif

	// Initialize filesystem
	if (!SPIFFS.begin(true)) {
		RNS::error("SPIFFS initialization failed!");
		return;
	}
	RNS::FileSystem universal_filesystem = new UniversalFileSystem();
	universal_filesystem.init();
	RNS::Utilities::OS::register_filesystem(universal_filesystem);

	// Initialize TCP interface with server from tcp_config.h
	TCPClientInterface* tcp_iface = new TCPClientInterface();
	tcp_iface->set_target_host(TCP_SERVER_HOST);
	tcp_iface->set_target_port(TCP_SERVER_PORT);
	arduino_tcp_interface = tcp_iface;  // Use global so it persists beyond setup()
	arduino_tcp_interface.mode(RNS::Type::Interface::MODE_GATEWAY);
	RNS::Transport::register_interface(arduino_tcp_interface);
	arduino_tcp_interface.start();

	// Initialize and start Reticulum
	reticulum.start();

	// Create server identity and destination
	// (using global identity for display access)
	arduino_server_identity = RNS::Identity();
	arduino_server_destination = RNS::Destination(
		arduino_server_identity,
		RNS::Type::Destination::IN,
		RNS::Type::Destination::SINGLE,
		APP_NAME,
		"link_server"
	);
	arduino_server_destination.set_link_established_callback(client_connected);

	// Configure display with data sources
	#ifdef HAS_DISPLAY
	RNS::Display::set_identity(arduino_server_identity);
	RNS::Display::set_interface(&arduino_tcp_interface);
	RNS::Display::set_reticulum(&reticulum);
	#endif

	RNS::log(
		"Link example <" +
		arduino_server_destination.hash().toHex() +
		"> running, waiting for a connection."
	);
	RNS::log("Send newline via Serial to announce");
}

// Arduino loop function - runs repeatedly
void loop() {
	// Run Reticulum event loop
	reticulum.loop();

	// Update display
	#ifdef HAS_DISPLAY
	RNS::Display::update();
	#endif

	// Handle Serial input for manual announce
	while (Serial.available() > 0) {
		char ch = Serial.read();
		if (ch == '\n' || ch == '\r') {
			if (arduino_server_destination) {
				arduino_server_destination.announce();
				RNS::log("Sent announce from " + arduino_server_destination.hash().toHex());
			}
		}
	}

	delay(10);
}

#else

// Signal handler function
void cleanup_handler(int signum) {
	if (signum == SIGINT) {
		printf("\nCtrl+C detected. Performing cleanup...\n");

		printf("Cleanup complete. Exiting.\n");
		_exit(0);
	}
}

// This part of the program runs at startup,
// and parses input of from the user, and then
// starts up the desired program mode.
int main(int argc, char *argv[]) {

#if defined(MEM_LOG)
	RNS::loglevel(RNS::LOG_MEM);
#else
	// Use DEBUG to see resource handling
	RNS::loglevel(RNS::LOG_DEBUG);
	//RNS::loglevel(RNS::LOG_NOTICE);
	//RNS::loglevel(RNS::LOG_TRACE);
#endif

	// Register the signal handler for SIGINT
    signal(SIGINT, cleanup_handler);

	// Setup non-blocking input
	int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
	fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

	// Initialize and register filesystem
	RNS::FileSystem universal_filesystem = new UniversalFileSystem();
	universal_filesystem.init();
	RNS::Utilities::OS::register_filesystem(universal_filesystem);

	// Parse interface options
	std::string tcp_host;
	int tcp_port = 0;
	std::string auto_ifname;  // Interface name for AutoInterface
	bool use_auto = false;
	int arg_offset = 0;  // Offset for parsing remaining args after interface option
	for (int i = 1; i < argc; i++) {
		if (strcmp(argv[i], "--tcp") == 0 && i + 1 < argc) {
			std::string tcp_arg = argv[i + 1];
			size_t colon = tcp_arg.find(':');
			if (colon != std::string::npos) {
				tcp_host = tcp_arg.substr(0, colon);
				tcp_port = std::stoi(tcp_arg.substr(colon + 1));
			} else {
				tcp_host = tcp_arg;
				tcp_port = 4965;  // Default Python RNS TCP port
			}
			arg_offset = 2;  // Skip --tcp and host:port
			break;
		}
		else if (strcmp(argv[i], "--auto") == 0) {
			use_auto = true;
			// Optional interface name argument
			if (i + 1 < argc && argv[i + 1][0] != '-') {
				auto_ifname = argv[i + 1];
				arg_offset = 2;
			} else {
				arg_offset = 1;
			}
			break;
		}
	}

	// Initialize and register interface
	RNS::Interface active_interface(RNS::Type::NONE);
	if (!tcp_host.empty()) {
		// Use TCP interface
		printf("Using TCP interface: %s:%d\n", tcp_host.c_str(), tcp_port);
		TCPClientInterface* tcp_iface = new TCPClientInterface();
		tcp_iface->set_target_host(tcp_host);
		tcp_iface->set_target_port(tcp_port);
		active_interface = tcp_iface;
	} else if (use_auto) {
		// Use AutoInterface (IPv6 multicast discovery)
		printf("Using AutoInterface (IPv6 multicast discovery)\n");
		AutoInterface* auto_iface = new AutoInterface();
		if (!auto_ifname.empty()) {
			auto_iface->set_interface_name(auto_ifname);
			printf("  Network interface: %s\n", auto_ifname.c_str());
		}
		active_interface = auto_iface;
	} else {
		// Use UDP interface (default)
		printf("Using UDP interface\n");
		UDPInterface* udp_iface = new UDPInterface();
		// For interop testing with Python: C++ listens on 14242, sends to 127.0.0.1:14243
		// Python listens on 127.0.0.1:14243, sends to 127.0.0.1:14242
		udp_iface->set_local_port(14242);
		udp_iface->set_remote_host("127.0.0.1");
		udp_iface->set_remote_port(14243);
		active_interface = udp_iface;
	}
	active_interface.mode(RNS::Type::Interface::MODE_GATEWAY);
	RNS::Transport::register_interface(active_interface);
	active_interface.start();

	// Initialize and start Reticulum
	reticulum.start();

	// Adjust argc/argv to skip --tcp arguments
	int effective_argc = argc - arg_offset;
	char** effective_argv = argv;
	if (arg_offset > 0) {
		// Shift arguments after --tcp
		static char* adjusted_argv[32];
		adjusted_argv[0] = argv[0];
		int j = 1;
		for (int i = 1; i < argc; i++) {
			if (strcmp(argv[i], "--tcp") == 0 && i + 1 < argc) {
				i++;  // Skip --tcp and its argument
				continue;
			}
			else if (strcmp(argv[i], "--auto") == 0) {
				// Skip --auto and optional interface name
				if (i + 1 < argc && argv[i + 1][0] != '-') {
					i++;  // Skip interface name too
				}
				continue;
			}
			adjusted_argv[j++] = argv[i];
		}
		effective_argc = j;
		effective_argv = adjusted_argv;
	}

	if (effective_argc <= 1) {
		printf("\nMust specify a destination for client mode, or \"-s\" or \"--server\" for server mode.\n\n");
		printf("Interface options:\n");
		printf("  --tcp host:port  - Use TCP interface\n");
		printf("  --auto [ifname]  - Use AutoInterface (IPv6 multicast discovery)\n");
		printf("  (default)        - Use UDP interface\n\n");
		printf("Other options:\n");
		printf("  --test-aes       - Run AES-256-CBC test\n\n");
		return -1;
	}
	// AES test mode
	if (strcmp(effective_argv[1], "--test-aes") == 0) {
		bool result = test_aes_256_cbc();
		return result ? 0 : 1;
	}
	if (strcmp(effective_argv[1], "--server") == 0 || strcmp(effective_argv[1], "-s") == 0) {
		server();
	}
	else {
		// Check for optional second arg for auto-send size (e.g., "./program <hash> 1048576")
		if (effective_argc >= 3) {
			auto_send_size = std::stoul(effective_argv[2]);
			RNS::log("Auto-send mode: will send " + std::to_string(auto_send_size) + " bytes after link established");
		}
		client(effective_argv[1]);
	}

	printf("\nLoop exited. Performing cleanup...\n");

	printf("Cleanup complete. Exiting.\n");

	return 0;
}

#endif // ARDUINO
