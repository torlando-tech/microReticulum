---
phase: 02-echo-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/common/auto_interface/AutoInterface.h
  - examples/common/auto_interface/AutoInterface.cpp
autonomous: true

must_haves:
  truths:
    - "AutoInterface logs when own multicast echo is received"
    - "Warning logged if no echo received for 6.5 seconds"
    - "Error logged if multicast echo never received (firewall/network issue)"
    - "carrier_changed flag set on state transitions"
  artifacts:
    - path: "examples/common/auto_interface/AutoInterface.h"
      provides: "Echo tracking constants, member variables, and accessors"
      contains: "MCAST_ECHO_TIMEOUT"
    - path: "examples/common/auto_interface/AutoInterface.cpp"
      provides: "Echo tracking implementation"
      contains: "check_echo_timeout"
  key_links:
    - from: "add_or_refresh_peer()"
      to: "_last_multicast_echo"
      via: "timestamp update when own address detected"
      pattern: "_last_multicast_echo = timestamp"
    - from: "loop()"
      to: "check_echo_timeout()"
      via: "method call"
      pattern: "check_echo_timeout\\(\\)"
---

<objective>
Implement multicast echo tracking for carrier detection and diagnostics.

Purpose: When multicast echo is not received back, the interface should detect carrier loss and warn about potential firewall/network issues. This enables reliable network diagnostics and allows higher layers to respond to connectivity changes.

Output: AutoInterface with echo tracking that logs carrier state changes and exposes carrier_changed flag.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-echo-tracking/02-RESEARCH.md
@examples/common/auto_interface/AutoInterface.h
@examples/common/auto_interface/AutoInterface.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add echo tracking infrastructure to header</name>
  <files>examples/common/auto_interface/AutoInterface.h</files>
  <action>
Add the following to AutoInterface.h:

1. Add constant in the public section with other protocol constants:
   ```cpp
   static constexpr double MCAST_ECHO_TIMEOUT = 6.5;  // seconds (matches Python RNS)
   ```

2. Add method declaration in the private section after `expire_stale_peers()`:
   ```cpp
   void check_echo_timeout();
   ```

3. Add member variables in the private section after `double _last_announce = 0;`:
   ```cpp
   // Echo tracking (multicast carrier detection)
   double _last_multicast_echo = 0;      // Timestamp of last echo received
   bool _initial_echo_received = false;   // True if we've ever received an echo
   bool _timed_out = false;               // True if echo timeout triggered
   bool _carrier_changed = false;         // Flag for transport layer
   bool _firewall_warning_logged = false; // Prevent repeated firewall warnings
   ```

4. Add public accessors for transport layer integration (add in public section after `peer_count()`):
   ```cpp
   // Carrier state accessors
   bool carrier_changed() const { return _carrier_changed; }
   void clear_carrier_changed() { _carrier_changed = false; }
   bool is_timed_out() const { return _timed_out; }
   ```
  </action>
  <verify>File compiles without errors: `grep -n "MCAST_ECHO_TIMEOUT\|check_echo_timeout\|_last_multicast_echo\|carrier_changed" examples/common/auto_interface/AutoInterface.h`</verify>
  <done>AutoInterface.h contains MCAST_ECHO_TIMEOUT constant, check_echo_timeout() declaration, echo tracking member variables, and public accessor methods.</done>
</task>

<task type="auto">
  <name>Task 2: Implement echo tracking logic</name>
  <files>examples/common/auto_interface/AutoInterface.cpp</files>
  <action>
Modify AutoInterface.cpp to implement echo tracking:

1. **Modify add_or_refresh_peer() (ESP32/Arduino version, around line 1247)**:
   Replace the early return when own address is detected with echo timestamp update:
   ```cpp
   void AutoInterface::add_or_refresh_peer(const IPv6Address& addr, double timestamp) {
       // Check if this is our own address (multicast echo)
       if (addr == _link_local_ip) {
           // Update echo tracking
           _last_multicast_echo = timestamp;
           if (!_initial_echo_received) {
               _initial_echo_received = true;
               INFO("AutoInterface: Initial multicast echo received");
           }
           TRACE("AutoInterface: Multicast echo received");
           return;
       }
       // ... rest of existing peer logic unchanged
   ```

2. **Modify add_or_refresh_peer() (POSIX version, around line 1272)**:
   Same change for the POSIX version:
   ```cpp
   void AutoInterface::add_or_refresh_peer(const struct in6_addr& addr, double timestamp) {
       // Check if this is our own address (multicast echo)
       if (memcmp(&addr, &_link_local_address, sizeof(addr)) == 0) {
           // Update echo tracking
           _last_multicast_echo = timestamp;
           if (!_initial_echo_received) {
               _initial_echo_received = true;
               INFO("AutoInterface: Initial multicast echo received");
           }
           TRACE("AutoInterface: Multicast echo received");
           return;
       }
       // ... rest of existing peer logic unchanged
   ```

3. **Add check_echo_timeout() implementation** (add before expire_stale_peers(), around line 1300):
   ```cpp
   void AutoInterface::check_echo_timeout() {
       double now = RNS::Utilities::OS::time();

       // Check if echo has timed out
       if (_last_multicast_echo > 0 && (now - _last_multicast_echo) > MCAST_ECHO_TIMEOUT) {
           if (!_timed_out) {
               _carrier_changed = true;
               WARNING("AutoInterface: Multicast echo timeout. Carrier lost.");
           }
           _timed_out = true;
       } else if (_last_multicast_echo > 0) {
           if (_timed_out) {
               _carrier_changed = true;
               WARNING("AutoInterface: Carrier recovered");
           }
           _timed_out = false;
       }

       // Warning if no initial echo ever received (firewall/network issue)
       // Only log this once after a grace period (3x announce interval = ~4.8s)
       if (!_initial_echo_received && !_firewall_warning_logged &&
           _last_announce > 0 && (now - _last_announce > ANNOUNCE_INTERVAL * 3)) {
           ERROR("AutoInterface: No multicast echoes received. Firewall or network may be blocking multicast.");
           _firewall_warning_logged = true;
       }
   }
   ```

4. **Integrate into loop()** (add after `expire_deque_entries();` call, around line 263):
   ```cpp
   // Check multicast echo timeout
   check_echo_timeout();
   ```

Important implementation notes:
- The firewall warning uses `_last_announce > 0` check to avoid triggering before first announce
- Grace period of 3x ANNOUNCE_INTERVAL (~4.8s) gives time for first echo to arrive
- `_firewall_warning_logged` prevents spamming the same error message
- State transitions (carrier lost/recovered) set `_carrier_changed` for transport layer integration
  </action>
  <verify>
Build the project to verify no compilation errors. Grep to confirm implementation:
```bash
grep -n "check_echo_timeout\|_last_multicast_echo\|Carrier lost\|Carrier recovered\|No multicast echoes" examples/common/auto_interface/AutoInterface.cpp
```
  </verify>
  <done>
- add_or_refresh_peer() updates echo timestamp when own address detected (both platforms)
- check_echo_timeout() logs carrier lost/recovered warnings
- check_echo_timeout() logs firewall error if no initial echo after grace period
- loop() calls check_echo_timeout()
- carrier_changed flag set on state transitions
  </done>
</task>

</tasks>

<verification>
1. **Grep verification**: All echo tracking patterns present in source files
2. **Build verification**: Project compiles without errors
3. **Requirements coverage**:
   - ECHO-01: `_last_multicast_echo` updated in `add_or_refresh_peer()`
   - ECHO-02: "Carrier lost" WARNING logged after 6.5s timeout
   - ECHO-03: "No multicast echoes received" ERROR logged after grace period
   - ECHO-04: `_carrier_changed = true` on state transitions
</verification>

<success_criteria>
- AutoInterface.h contains MCAST_ECHO_TIMEOUT = 6.5 constant
- AutoInterface.h contains _last_multicast_echo, _initial_echo_received, _timed_out, _carrier_changed members
- AutoInterface.h contains carrier_changed(), clear_carrier_changed(), is_timed_out() accessors
- AutoInterface.cpp add_or_refresh_peer() updates echo timestamp when own address detected
- AutoInterface.cpp contains check_echo_timeout() implementation with carrier lost/recovered logic
- AutoInterface.cpp loop() calls check_echo_timeout()
- Project compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-echo-tracking/02-01-SUMMARY.md`
</output>
