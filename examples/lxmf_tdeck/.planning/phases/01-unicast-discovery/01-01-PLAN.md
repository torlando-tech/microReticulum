---
phase: 01-unicast-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/common/auto_interface/AutoInterfacePeer.h
  - examples/common/auto_interface/AutoInterface.h
  - examples/common/auto_interface/AutoInterface.cpp
autonomous: true

must_haves:
  truths:
    - "T-Deck sends unicast discovery token to each known peer every ~5.2 seconds"
    - "T-Deck receives and processes unicast discovery from other peers"
    - "Peers discovered via unicast are added/refreshed in peer table"
    - "Peer connections maintained even when multicast is unreliable"
  artifacts:
    - path: "examples/common/auto_interface/AutoInterfacePeer.h"
      provides: "Peer struct with last_outbound tracking"
      contains: "last_outbound"
    - path: "examples/common/auto_interface/AutoInterface.h"
      provides: "Class members for unicast discovery socket/port/interval"
      contains: "_unicast_discovery_socket"
    - path: "examples/common/auto_interface/AutoInterface.cpp"
      provides: "Unicast discovery implementation"
      contains: ["setup_unicast_discovery_socket", "process_unicast_discovery", "reverse_announce", "send_reverse_peering"]
  key_links:
    - from: "AutoInterface::loop()"
      to: "process_unicast_discovery()"
      via: "direct call in loop"
      pattern: "process_unicast_discovery\\(\\)"
    - from: "AutoInterface::loop()"
      to: "send_reverse_peering()"
      via: "direct call in loop"
      pattern: "send_reverse_peering\\(\\)"
    - from: "AutoInterface::start()"
      to: "setup_unicast_discovery_socket()"
      via: "socket initialization"
      pattern: "setup_unicast_discovery_socket\\(\\)"
    - from: "AutoInterface::stop()"
      to: "_unicast_discovery_socket cleanup"
      via: "close() call"
      pattern: "close\\(_unicast_discovery_socket\\)"
---

<objective>
Implement unicast discovery (reverse peering) for AutoInterface to maintain peer connections even when multicast is unreliable.

Purpose: Multicast packets are often dropped or throttled by WiFi infrastructure. Unicast discovery sends tokens directly to known peers, ensuring they stay in the peer table even if multicast fails.

Output: AutoInterface with full unicast discovery support, interoperable with Python RNS and Columba phones.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-unicast-discovery/01-RESEARCH.md

# Source files to modify
@examples/common/auto_interface/AutoInterfacePeer.h
@examples/common/auto_interface/AutoInterface.h
@examples/common/auto_interface/AutoInterface.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unicast discovery state and infrastructure</name>
  <files>
    examples/common/auto_interface/AutoInterfacePeer.h
    examples/common/auto_interface/AutoInterface.h
  </files>
  <action>
Add unicast discovery tracking to AutoInterfacePeer and AutoInterface classes.

**AutoInterfacePeer.h:**
Add `last_outbound` field to track when we last sent unicast discovery to this peer:
```cpp
double last_outbound;    // Timestamp of last unicast discovery sent to this peer
```
Initialize to 0 in constructors so first send happens immediately.

**AutoInterface.h:**
Add class members in the private section near existing sockets:
```cpp
// Unicast discovery (reverse peering)
int _unicast_discovery_socket = -1;   // Port 29717 (discovery_port+1)
uint16_t _unicast_discovery_port;     // = _discovery_port + 1
double _reverse_peering_interval;     // = ANNOUNCE_INTERVAL * 3.25 = 5.2s
```

Add method declarations in private section:
```cpp
// Unicast discovery (reverse peering)
bool setup_unicast_discovery_socket();
void process_unicast_discovery();
void reverse_announce(AutoInterfacePeer& peer);
void send_reverse_peering();
```

Constants are already defined (ANNOUNCE_INTERVAL = 1.6s), so the interval is computed at runtime in start().
  </action>
  <verify>
Code compiles: `cd examples/lxmf_tdeck && pio run -e T-Deck` (may fail at link stage until Task 2 implements the methods, but header syntax should be valid)
  </verify>
  <done>
- AutoInterfacePeer has `last_outbound` field initialized to 0
- AutoInterface has `_unicast_discovery_socket`, `_unicast_discovery_port`, `_reverse_peering_interval` members
- AutoInterface declares `setup_unicast_discovery_socket()`, `process_unicast_discovery()`, `reverse_announce()`, `send_reverse_peering()` methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement unicast discovery methods (ESP32)</name>
  <files>examples/common/auto_interface/AutoInterface.cpp</files>
  <action>
Implement the four unicast discovery methods for ESP32 (inside `#ifdef ARDUINO` blocks). Follow the patterns from 01-RESEARCH.md exactly.

**In start() method:**
After `calculate_discovery_token()` and before `setup_discovery_socket()`:
```cpp
// Calculate unicast discovery parameters
_unicast_discovery_port = _discovery_port + 1;  // 29716 + 1 = 29717
_reverse_peering_interval = ANNOUNCE_INTERVAL * 3.25;  // 1.6 * 3.25 = 5.2s
```

After `setup_data_socket()` call, add unicast discovery socket setup:
```cpp
// Set up unicast discovery socket
if (!setup_unicast_discovery_socket()) {
    WARNING("AutoInterface: Could not set up unicast discovery socket (multicast-only mode)");
} else {
    INFO("AutoInterface: Unicast discovery enabled on port " + std::to_string(_unicast_discovery_port));
}
```

**setup_unicast_discovery_socket():**
Create and bind UDP socket to link-local address on `_unicast_discovery_port`:
- Create AF_INET6, SOCK_DGRAM socket
- Set SO_REUSEADDR
- Bind to `_link_local_address` + `_unicast_discovery_port` + `_if_index` scope
- Set non-blocking with fcntl
- Return true on success, false on failure (with appropriate logging)

**process_unicast_discovery():**
Poll `_unicast_discovery_socket` for incoming packets:
- recvfrom() in a while loop (non-blocking)
- Validate discovery token hash (same logic as process_discovery)
- Call add_or_refresh_peer() for valid peers
- Use ipv6_to_compressed_string() for source address conversion (critical for hash match)

**reverse_announce(peer):**
Send our discovery token directly to a peer:
- Create temporary AF_INET6 UDP socket
- Build sockaddr_in6 with peer.address, `_unicast_discovery_port`, `_if_index`
- sendto() the `_discovery_token` (32 bytes)
- Close socket
- Log at TRACE level on success, WARNING on failure

**send_reverse_peering():**
Check all peers and send unicast discovery if interval elapsed:
- Loop through `_peers`
- Skip if `peer.is_local`
- If `now > peer.last_outbound + _reverse_peering_interval`:
  - Call `reverse_announce(peer)`
  - Update `peer.last_outbound = now`

**In loop() method:**
After `process_discovery()` call:
```cpp
// Process incoming unicast discovery
process_unicast_discovery();
```

After `process_data()` call (or alongside discovery processing):
```cpp
// Send unicast discovery to known peers
send_reverse_peering();
```

**In stop() method:**
After existing socket cleanup:
```cpp
if (_unicast_discovery_socket > -1) {
    close(_unicast_discovery_socket);
    _unicast_discovery_socket = -1;
}
```

IMPORTANT: Use the existing `ipv6_to_compressed_string()` helper for address-to-string conversion. The discovery token hash MUST match Python's inet_ntop compressed output format.
  </action>
  <verify>
Build succeeds: `cd examples/lxmf_tdeck && pio run -e T-Deck`

No compiler errors or warnings related to the new methods.
  </verify>
  <done>
- `setup_unicast_discovery_socket()` creates socket bound to link-local:29717
- `process_unicast_discovery()` receives and validates unicast discovery packets
- `reverse_announce()` sends discovery token to a specific peer
- `send_reverse_peering()` iterates peers and sends if interval elapsed
- `loop()` calls `process_unicast_discovery()` and `send_reverse_peering()`
- `stop()` closes `_unicast_discovery_socket`
- `start()` computes `_unicast_discovery_port` and `_reverse_peering_interval`
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement unicast discovery methods (POSIX)</name>
  <files>examples/common/auto_interface/AutoInterface.cpp</files>
  <action>
Implement the same four unicast discovery methods for POSIX/Linux (inside `#else` blocks or after `#endif // ARDUINO`).

The logic is identical to ESP32, with minor differences:
- Use `ioctl(fd, FIONBIO, &flags)` instead of `fcntl()` for non-blocking (match existing pattern)
- Use `inet_ntop()` for address-to-string conversion (match existing process_discovery pattern)
- Socket operations are the same (POSIX sockets work identically)

**POSIX-specific setup_unicast_discovery_socket():**
Same as ESP32 but use `ioctl(FIONBIO)` for non-blocking.

**POSIX-specific process_unicast_discovery():**
Same as ESP32 but use `inet_ntop()` for address string.

**POSIX-specific reverse_announce():**
Same as ESP32 implementation (POSIX sockets).

**POSIX-specific send_reverse_peering():**
Same as ESP32 implementation.

**In stop() (POSIX section):**
Add unicast socket cleanup identical to ESP32.

**In start() (POSIX section):**
Add port/interval calculation and socket setup (same as ESP32 section).

NOTE: The loop() method is shared (not platform-specific), so no changes needed there - the calls already added in Task 2 will work for both platforms.
  </action>
  <verify>
POSIX build succeeds (if available): `g++ -c examples/common/auto_interface/AutoInterface.cpp -I src -std=c++17` (optional - primary target is ESP32)

Review code compiles for T-Deck: `cd examples/lxmf_tdeck && pio run -e T-Deck`
  </verify>
  <done>
- POSIX implementation mirrors ESP32 implementation
- Socket operations use POSIX-standard patterns
- Both platforms share the same loop() integration
  </done>
</task>

</tasks>

<verification>
Build verification:
```bash
cd /home/tyler/repos/public/microReticulum/examples/lxmf_tdeck
pio run -e T-Deck
```

Code review checklist:
- [ ] `_unicast_discovery_port` computed as `_discovery_port + 1` (29717)
- [ ] `_reverse_peering_interval` computed as `ANNOUNCE_INTERVAL * 3.25` (5.2s)
- [ ] `last_outbound` field added to AutoInterfacePeer and initialized to 0
- [ ] `setup_unicast_discovery_socket()` binds to link-local address (not in6addr_any)
- [ ] `process_unicast_discovery()` uses same hash validation as `process_discovery()`
- [ ] `reverse_announce()` sends to `_unicast_discovery_port` (not `_discovery_port`)
- [ ] `send_reverse_peering()` checks `peer.last_outbound + _reverse_peering_interval`
- [ ] Socket closed in `stop()` method
- [ ] `sin6_scope_id = _if_index` set for all link-local operations
</verification>

<success_criteria>
1. Build succeeds for T-Deck target without errors
2. All four requirements addressed:
   - DISC-01: `reverse_announce()` sends tokens to known peers on port 29717
   - DISC-02: `send_reverse_peering()` checks 5.2s interval per peer
   - DISC-03: `setup_unicast_discovery_socket()` + `process_unicast_discovery()` listen on 29717
   - DISC-04: `add_or_refresh_peer()` called from `process_unicast_discovery()` (same as multicast)
3. Code follows established patterns from existing multicast implementation
4. Ready for flash and testing with Columba phones
</success_criteria>

<output>
After completion, create `.planning/phases/01-unicast-discovery/01-01-SUMMARY.md` using the summary template.
</output>
