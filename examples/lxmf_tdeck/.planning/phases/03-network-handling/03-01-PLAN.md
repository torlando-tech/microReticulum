---
phase: 03-network-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/common/auto_interface/AutoInterface.h
  - examples/common/auto_interface/AutoInterface.cpp
autonomous: true

must_haves:
  truths:
    - "AutoInterface detects when IPv6 link-local address changes"
    - "Data socket rebound to new address automatically"
    - "Unicast discovery socket rebound to new address automatically"
    - "Discovery token recalculated on address change"
    - "carrier_changed flag set on address change"
    - "Logging indicates network state changes"
  artifacts:
    - path: "examples/common/auto_interface/AutoInterface.h"
      provides: "PEER_JOB_INTERVAL constant, _last_peer_job member, check_link_local_address() declaration"
      contains: "PEER_JOB_INTERVAL"
    - path: "examples/common/auto_interface/AutoInterface.cpp"
      provides: "check_link_local_address() implementation for ESP32 and POSIX"
      contains: "check_link_local_address"
  key_links:
    - from: "AutoInterface::loop()"
      to: "check_link_local_address()"
      via: "call every PEER_JOB_INTERVAL seconds"
      pattern: "check_link_local_address\\(\\)"
    - from: "check_link_local_address()"
      to: "setup_data_socket()"
      via: "rebind on address change"
      pattern: "setup_data_socket\\(\\)"
    - from: "check_link_local_address()"
      to: "calculate_discovery_token()"
      via: "recalculate token on address change"
      pattern: "calculate_discovery_token\\(\\)"
---

<objective>
Implement network change handling so AutoInterface gracefully recovers when the IPv6 link-local address changes (e.g., after WiFi reconnection or network interface reset).

Purpose: Ensure AutoInterface maintains connectivity even when network conditions change, matching Python RNS behavior for robust peer discovery.

Output: AutoInterface that detects address changes, rebinds sockets, recalculates discovery token, and signals carrier_changed to Transport layer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-network-handling/03-RESEARCH.md

# Source files to modify
@examples/common/auto_interface/AutoInterface.h
@examples/common/auto_interface/AutoInterface.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PEER_JOB_INTERVAL constant and check_link_local_address() declaration</name>
  <files>examples/common/auto_interface/AutoInterface.h</files>
  <action>
Add the following to AutoInterface.h:

1. Add constant after REVERSE_PEERING_INTERVAL (around line 39):
```cpp
static constexpr double PEER_JOB_INTERVAL = 4.0;  // seconds (matches Python RNS)
```

2. Add member variable after `_last_announce` (around line 154):
```cpp
double _last_peer_job = 0;  // Timestamp of last peer job check
```

3. Add method declaration in the private section (after check_echo_timeout around line 104):
```cpp
void check_link_local_address();
```

The constant matches Python RNS exactly. The peer job runs every 4 seconds to check for address changes without excessive overhead.
  </action>
  <verify>
Grep for PEER_JOB_INTERVAL in the header file:
```bash
grep -n "PEER_JOB_INTERVAL\|_last_peer_job\|check_link_local_address" examples/common/auto_interface/AutoInterface.h
```
Should show all three additions.
  </verify>
  <done>
AutoInterface.h contains PEER_JOB_INTERVAL constant (4.0), _last_peer_job member variable, and check_link_local_address() method declaration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement check_link_local_address() and integrate into loop()</name>
  <files>examples/common/auto_interface/AutoInterface.cpp</files>
  <action>
Implement check_link_local_address() for both ESP32 and POSIX platforms, then integrate into loop().

**ESP32 Implementation (add after get_link_local_address() around line 398):**

```cpp
#ifdef ARDUINO

void AutoInterface::check_link_local_address() {
    // ESP32: Check if link-local address changed
    if (WiFi.status() != WL_CONNECTED) {
        WARNING("AutoInterface: WiFi disconnected during address check");
        return;
    }

    IPv6Address current_ip = WiFi.localIPv6();

    // Check for valid address (not all zeros)
    if (current_ip[0] == 0 && current_ip[1] == 0) {
        WARNING("AutoInterface: Lost IPv6 address");
        return;
    }

    // Compare with stored address
    if (current_ip == _link_local_ip) {
        return;  // No change
    }

    // Address changed!
    std::string old_addr_str = _link_local_address_str;

    // Update stored addresses
    _link_local_ip = current_ip;
    for (int i = 0; i < 16; i++) {
        ((uint8_t*)&_link_local_address)[i] = current_ip[i];
    }

    // Get new address string in compressed format
    uint8_t addr_bytes[16];
    for (int i = 0; i < 16; i++) {
        addr_bytes[i] = current_ip[i];
    }
    _link_local_address_str = ipv6_to_compressed_string(addr_bytes);

    WARNING("AutoInterface: Link-local address changed from " + old_addr_str + " to " + _link_local_address_str);

    // Close and rebind data socket
    if (_data_socket > -1) {
        close(_data_socket);
        _data_socket = -1;
    }
    if (!setup_data_socket()) {
        WARNING("AutoInterface: Failed to rebind data socket after address change");
        _data_socket_ok = false;
    } else {
        _data_socket_ok = true;
        INFO("AutoInterface: Data socket rebound to new address");
    }

    // Close and rebind unicast discovery socket
    if (_unicast_discovery_socket > -1) {
        close(_unicast_discovery_socket);
        _unicast_discovery_socket = -1;
    }
    if (!setup_unicast_discovery_socket()) {
        WARNING("AutoInterface: Failed to rebind unicast discovery socket after address change");
    } else {
        INFO("AutoInterface: Unicast discovery socket rebound to new address");
    }

    // Recalculate discovery token (critical - token includes address)
    calculate_discovery_token();
    INFO("AutoInterface: Discovery token recalculated: " + _discovery_token.toHex());

    // Signal change to Transport layer
    _carrier_changed = true;
}

#else  // POSIX
```

**POSIX Implementation (add after ESP32 implementation):**

```cpp
void AutoInterface::check_link_local_address() {
    // POSIX: Check if link-local address changed
    struct in6_addr old_addr = _link_local_address;
    std::string old_addr_str = _link_local_address_str;

    // Temporarily clear to force refresh
    memset(&_link_local_address, 0, sizeof(_link_local_address));

    if (!get_link_local_address()) {
        // Lost address entirely - restore old address
        WARNING("AutoInterface: Lost link-local address during check");
        _link_local_address = old_addr;
        _link_local_address_str = old_addr_str;
        return;
    }

    // Check if address changed
    if (memcmp(&old_addr, &_link_local_address, sizeof(old_addr)) == 0) {
        return;  // No change
    }

    // Address changed!
    WARNING("AutoInterface: Link-local address changed from " + old_addr_str + " to " + _link_local_address_str);

    // Close and rebind data socket
    if (_data_socket > -1) {
        close(_data_socket);
        _data_socket = -1;
    }
    if (!setup_data_socket()) {
        WARNING("AutoInterface: Failed to rebind data socket after address change");
    } else {
        INFO("AutoInterface: Data socket rebound to new address");
    }

    // Close and rebind unicast discovery socket
    if (_unicast_discovery_socket > -1) {
        close(_unicast_discovery_socket);
        _unicast_discovery_socket = -1;
    }
    if (!setup_unicast_discovery_socket()) {
        WARNING("AutoInterface: Failed to rebind unicast discovery socket after address change");
    } else {
        INFO("AutoInterface: Unicast discovery socket rebound to new address");
    }

    // Recalculate discovery token (critical - token includes address)
    calculate_discovery_token();
    INFO("AutoInterface: Discovery token recalculated: " + _discovery_token.toHex());

    // Signal change to Transport layer
    _carrier_changed = true;
}

#endif  // ARDUINO
```

**Note:** The ipv6_to_compressed_string() function already exists at the top of AutoInterface.cpp (lines 31-77).

**Integrate into loop() (modify around line 267, after expire_deque_entries()):**

Add peer job check at the end of loop(), before the closing brace:

```cpp
    // Periodic peer job (every 4 seconds) - check for address changes
    if (now - _last_peer_job >= PEER_JOB_INTERVAL) {
        check_link_local_address();
        _last_peer_job = now;
    }
```

**Important notes:**
- Do NOT rebind discovery socket (multicast address doesn't change)
- DO rebind unicast discovery socket (bound to link-local)
- Token recalculation is critical - peers won't recognize us with old token
- Peer table remains valid (their addresses didn't change)
  </action>
  <verify>
1. Check implementations exist:
```bash
grep -n "void AutoInterface::check_link_local_address" examples/common/auto_interface/AutoInterface.cpp
```
Should show two implementations (ESP32 and POSIX).

2. Check loop() integration:
```bash
grep -n "check_link_local_address\|PEER_JOB_INTERVAL" examples/common/auto_interface/AutoInterface.cpp
```
Should show usage in loop().

3. Build for ESP32:
```bash
cd examples/lxmf_tdeck && pio run -e tdeck 2>&1 | tail -20
```
Should compile without errors.
  </verify>
  <done>
check_link_local_address() implemented for both ESP32 and POSIX, integrated into loop() every 4 seconds. On address change: data socket rebound, unicast discovery socket rebound, discovery token recalculated, carrier_changed flag set, appropriate logging emitted.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compile verification:**
   ```bash
   cd examples/lxmf_tdeck && pio run -e tdeck
   ```
   Should compile without errors or warnings related to AutoInterface.

2. **Code inspection:**
   ```bash
   grep -A5 "PEER_JOB_INTERVAL" examples/common/auto_interface/AutoInterface.h
   grep -A50 "void AutoInterface::check_link_local_address" examples/common/auto_interface/AutoInterface.cpp | head -60
   ```
   Should show the constant and implementation.

3. **Integration check:**
   ```bash
   grep -B2 -A2 "check_link_local_address()" examples/common/auto_interface/AutoInterface.cpp | grep -v "^--$"
   ```
   Should show the call in loop() and the implementations.
</verification>

<success_criteria>
- [ ] PEER_JOB_INTERVAL constant (4.0) added to AutoInterface.h
- [ ] _last_peer_job member variable added to AutoInterface.h
- [ ] check_link_local_address() declared in AutoInterface.h
- [ ] check_link_local_address() implemented for ESP32 in AutoInterface.cpp
- [ ] check_link_local_address() implemented for POSIX in AutoInterface.cpp
- [ ] loop() calls check_link_local_address() every PEER_JOB_INTERVAL
- [ ] On address change: data socket rebound
- [ ] On address change: unicast discovery socket rebound
- [ ] On address change: discovery token recalculated
- [ ] On address change: carrier_changed flag set
- [ ] On address change: warning logged with old and new addresses
- [ ] Code compiles without errors for ESP32 target
</success_criteria>

<output>
After completion, create `.planning/phases/03-network-handling/03-01-SUMMARY.md`
</output>
